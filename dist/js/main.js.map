{"version":3,"sources":["movement.js","script.js"],"names":["enterRoomFromDirection","direction","let","isEncounterInThatRoom","maze","playerPosition","y","x","encounter","animationName","$","addClass","setTimeout","removeClass","moveToCenter","enterRoom","leaveRoomInDirection","hero","fromClass","directionMap","fromNorthEncounter","fromSouthEncounter","fromEastEncounter","fromWestEncounter","hasClass","score","duringGame","duringEncounter","question","directions","levelSelectWrapper","levelSelect","menuTrolls","menuHeader","doors","north","east","south","west","roomEncounter","white_troll","green_troll","yellow_troll","gold","emerald","diamond","exit","loadMaze","level","val","ajax","url","type","dataType","success","data","initializeMaze","updateMazeVisualization","error","alert","hideMenuItems","hide","mazeSize","rooms","getExitCoordinates","i","j","visited","getRandomInt","getDistance","handleUserInput","input","announce","includes","encounterAnnounce","movePlayer","handleEncounterInput","currentRoom","encounterType","encounterActions","closeDoors","action","message","openDoors","newX","newY","canMoveTo","remove","append","handleEncounter","renderMazeInConsole","displayEncounter","userInput","requiredAction","announcement","max","Math","floor","random","pos1","pos2","abs","visualization","Array","join","console","log","room","empty","text","keypress","e","which","this","toLowerCase"],"mappings":"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","file":"main.js","sourcesContent":["\nfunction enterRoomFromDirection(direction) {\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\n    let isEncounterInThatRoom = currentRoom.encounter !== null;\n    let animationName = '';\n\n    switch (direction) {\n        case \"north\":\n            animationName = isEncounterInThatRoom ? 'fromSouthEncounter' : 'arriveFromSouth';\n            break;\n        case \"south\":\n            animationName = isEncounterInThatRoom ? 'fromNorthEncounter' : 'arriveFromNorth';\n            break;\n        case \"east\":\n            animationName = isEncounterInThatRoom ? 'fromWestEncounter' : 'arriveFromWest';\n            break;\n        case \"west\":\n            animationName = isEncounterInThatRoom ? 'fromEastEncounter' : 'arriveFromEast';\n            break;\n    }\n\n    $('.hero').addClass(animationName);\n    // Wait for the animation to finish\n    setTimeout(function () {\n        // if it's an encounter, dont remove the animation class\n        if (!isEncounterInThatRoom) {\n            $('.hero').removeClass(animationName);\n            moveToCenter();\n        }\n    }, 1000);\n    enterRoom();\n}\n\nfunction leaveRoomInDirection(direction) {\n    let animationName = '';\n    switch (direction) {\n        case \"north\":\n            animationName = 'leaveToNorth';\n            break;\n        case \"south\":\n            animationName = 'leaveToSouth';\n            break;\n        case \"east\":\n            animationName = 'leaveToEast';\n            break;\n        case \"west\":\n            animationName = 'leaveToWest';\n            break;\n    }\n    $('.hero').addClass(animationName);\n    // Wait for the animation to finish\n    setTimeout(function () {\n        $('.hero').removeClass(animationName);\n    }, 1000);\n\n}\n\nfunction moveToCenter() {\n    const hero = $('.hero');\n    const directionMap = {\n        'fromNorthEncounter': 'toCenterFromNorth',\n        'fromSouthEncounter': 'toCenterFromSouth',\n        'fromEastEncounter': 'toCenterFromEast',\n        'fromWestEncounter': 'toCenterFromWest',\n    };\n\n    for (let fromClass in directionMap) {\n        if (hero.hasClass(fromClass)) {\n            hero.addClass(directionMap[fromClass])\n                .removeClass(fromClass);\n            break;\n        }\n    }\n\n    // now after animation finishes after 1 sec remove the toCenter class\n    setTimeout(function () {\n        hero.removeClass('toCenterFromNorth toCenterFromSouth toCenterFromEast toCenterFromWest');\n    }, 1000);\n}","// Global variables\r\nlet playerPosition = { x: 0, y: 0 };\r\nlet score = 0;\r\nlet duringGame = false;\r\nlet duringEncounter = false;\r\nlet question = false;\r\nconst directions = [\"north\", \"south\", \"east\", \"west\"];\r\n\r\nlet levelSelectWrapper = $('.maze__level-select');\r\nlet levelSelect = $('#level');\r\nlet menuTrolls = $('.maze__menu-troll');\r\nlet menuHeader = $('.menu__heading');\r\n\r\nconst doors = {\r\n    north: '<span class=\"doors doors--north\"></span>',\r\n    east: '<span class=\"doors doors--east\"></span>',\r\n    south: '<span class=\"doors doors--south\"></span>',\r\n    west: '<span class=\"doors doors--west\"></span>'\r\n}\r\n\r\nconst roomEncounter = {\r\n    white_troll: '<img class=\"troll white_troll\" src=\"./dist/assets/monsters/white-troll.png\" alt=\"White troll\">',\r\n    green_troll: '<img class=\"troll green_troll\" src=\"./dist/assets/monsters/green-troll.png\" alt=\"Green troll\">',\r\n    yellow_troll: '<img class=\"troll yellow_troll\" src=\"./dist/assets/monsters/yellow-troll.png\" alt=\"Yellow troll\">',\r\n    gold: '<img class=\"gold\" src=\"./dist/assets/items/gold.png\" alt=\"Gold\">',\r\n    emerald: '<img class=\"emerald\" src=\"./dist/assets/items/emerald.png\" alt=\"Emerald\">',\r\n    diamond: '<img class=\"diamond\" src=\"./dist/assets/items/diamond.png\" alt=\"Diamond\">',\r\n    exit: '<img src=\"./dist/assets/exit.png\" alt=\"Exit\">'\r\n}\r\n\r\n// User input handling\r\n$(\"#userInput\").keypress(function (e) {\r\n    if (e.which === 13) { // Enter key pressed\r\n        let input = $(this).val().toLowerCase();\r\n        handleUserInput(input);\r\n        // clear the input field\r\n        $(this).val(\"\");\r\n    }\r\n});\r\n\r\nfunction loadMaze() {\r\n    let level = levelSelect.val();\r\n\r\n    $.ajax({\r\n        url: './maze-configs/' + level + '.json',\r\n        type: 'GET',\r\n        dataType: 'json',\r\n        success: function (data) {\r\n            initializeMaze(data);\r\n            updateMazeVisualization();\r\n        },\r\n        error: function () {\r\n            alert('Failed to load maze.');\r\n        }\r\n    });\r\n}\r\n\r\nfunction hideMenuItems() {\r\n    menuTrolls.hide();\r\n    levelSelectWrapper.hide();\r\n    menuHeader.hide();\r\n}\r\n\r\nfunction initializeMaze(data) {\r\n    mazeSize = data.mazeSize;\r\n    maze = data.rooms;\r\n    exit = getExitCoordinates(data);\r\n\r\n    // Further maze initializations like marking rooms as unvisited can go here\r\n    for (let i = 0; i < mazeSize; i++) {\r\n        for (let j = 0; j < mazeSize; j++) {\r\n            maze[i][j].visited = false;\r\n        }\r\n    }\r\n\r\n    do {\r\n        playerPosition.x = getRandomInt(mazeSize);\r\n        playerPosition.y = getRandomInt(mazeSize);\r\n    } while (getDistance(playerPosition, exit) < 3);\r\n}\r\n\r\nfunction handleUserInput(input) {\r\n    if (input === \"start\" && !duringGame) {\r\n        duringGame = true;\r\n        hideMenuItems();\r\n        loadMaze();\r\n        announce(\"You are in a maze. Try to find the exit. Type 'help' for more instructions.\");\r\n    } else if (input === \"start\" && duringGame) {\r\n        announce(\"Do you want to return to main menu? Type 'yes' or 'no'.\");\r\n        question = true;\r\n    } else if (directions.includes(input)) {\r\n        // Check if the player is during an encounter. If so, notify them and prevent movement.\r\n        if (duringEncounter) {\r\n            encounterAnnounce(\"You can't leave until you've dealt with the encounter!\");\r\n        } else {\r\n            movePlayer(input);\r\n        }\r\n    } else if (duringEncounter) {\r\n        // Handle the encounter input\r\n        handleEncounterInput(input);\r\n    } else {\r\n        announce(\"Unknown command. Type 'help' for more instructions.\");\r\n    }\r\n}\r\n\r\nfunction handleEncounterInput(input) {\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    const encounterType = currentRoom.encounter;\r\n    closeDoors();\r\n\r\n    // Use an object to map user input to a particular action for an encounter type\r\n    const encounterActions = {\r\n        'white_troll': { action: 'punch', message: 'You punched the white troll! It ran away.' },\r\n        'green_troll': { action: 'kick', message: 'You kicked the green troll! Its gone now.' },\r\n        'yellow_troll': { action: 'throw', message: 'You threw a stone at the yellow troll! Its scared away.' },\r\n        'gold': { action: 'collect', message: `You collected gold!` },\r\n        'emerald': { action: 'grab', message: `You grabbed an emerald!` },\r\n        'diamond': { action: 'pick', message: `You picked up a diamond!` },\r\n        'exit': { action: 'exit', message: `You've found the exit! Congratulations.` }\r\n    };\r\n\r\n    if (encounterActions[encounterType] && input === encounterActions[encounterType].action) {\r\n        announce(encounterActions[encounterType].message);\r\n        encounterAnnounce(\"\");\r\n        currentRoom.encounter = null; // Remove the encounter\r\n        score += 10; // Increment score\r\n        duringEncounter = false;\r\n        moveToCenter();\r\n        openDoors();\r\n    } else {\r\n        encounterAnnounce(\"Wrong action! Try again.\");\r\n    }\r\n}\r\n\r\nfunction movePlayer(direction) {\r\n    let newX = playerPosition.x;\r\n    let newY = playerPosition.y;\r\n\r\n    switch (direction) {\r\n        case \"north\": newY--; break;\r\n        case \"south\": newY++; break;\r\n        case \"east\": newX++; break;\r\n        case \"west\": newX--; break;\r\n    }\r\n\r\n    if (canMoveTo(newX, newY, direction)) {\r\n        leaveRoomInDirection(direction);\r\n        setTimeout(function () {\r\n            playerPosition.x = newX;\r\n            playerPosition.y = newY;\r\n            enterRoomFromDirection(direction);\r\n        }, 1000);\r\n    } else {\r\n        announce(\"You can't go that way!\");\r\n    }\r\n}\r\n\r\nfunction canMoveTo(x, y, direction) {\r\n    return x >= 0 && y >= 0 && x < mazeSize && y < mazeSize && maze[playerPosition.y][playerPosition.x].doors[direction];\r\n}\r\n\r\n\r\nfunction updateMazeVisualization() {\r\n    // Clear any existing door elements from the previous room\r\n    $('.doors').remove();\r\n\r\n    // Fetch the current room based on player's position\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n\r\n    // Check for available doors and inject them into the maze\r\n    for (const direction in currentRoom.doors) {\r\n        if (currentRoom.doors[direction]) {\r\n            $(\"#maze\").append(doors[direction]);\r\n        }\r\n    }\r\n}\r\n\r\nfunction enterRoom() {\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n\r\n    if (!currentRoom.visited && currentRoom.encounter !== null) {\r\n        currentRoom.visited = true;\r\n        updateMazeVisualization();\r\n\r\n        if (currentRoom.encounter === \"exit\") {\r\n            announce(\"Congratulations! You found the exit!\");\r\n            // End game or progress to next level\r\n        } else {\r\n            duringEncounter = true;\r\n            handleEncounter();\r\n        }\r\n    } else {\r\n        announce(\"Nothing in this room\");\r\n        updateMazeVisualization();\r\n    }\r\n\r\n    renderMazeInConsole();\r\n    displayEncounter(currentRoom);\r\n}\r\n\r\nfunction handleEncounter(userInput = null) {\r\n    const x = playerPosition.x;\r\n    const y = playerPosition.y;\r\n    const encounter = maze[y][x].encounter;\r\n\r\n    if (!encounter) {\r\n        announce(\"The room is empty. Nothing to do here.\");\r\n        return;\r\n    }\r\n\r\n    let requiredAction = null;\r\n    let announcement = null;\r\n\r\n    switch (encounter) {\r\n        case 'diamond':\r\n            announcement = \"You've found a shining diamond! Type 'pick' to pick it up!\";\r\n            requiredAction = \"pick\";\r\n            break;\r\n        case 'white_troll':\r\n            announcement = \"You spotted a white troll! Type 'punch' to defeat it!\";\r\n            requiredAction = \"punch\";\r\n            break;\r\n        case 'emerald':\r\n            announcement = \"You've found a gleaming emerald! Type 'grab' to pick it up!\";\r\n            requiredAction = \"grab\";\r\n            break;\r\n        case 'green_troll':\r\n            announcement = \"You encountered a green troll! Type 'kick' to kick it away!\";\r\n            requiredAction = \"kick\";\r\n            break;\r\n        case 'yellow_troll':\r\n            announcement = \"Beware! A yellow troll is blocking your way! Type 'throw' to throw a stone at it!\";\r\n            requiredAction = \"throw\";\r\n            break;\r\n        case 'gold':\r\n            announcement = \"Golden treasures await! Type 'collect' to collect them!\";\r\n            requiredAction = \"collect\";\r\n            break;\r\n        case 'exit':\r\n            announcement = \"You've found the exit! Type 'exit' to leave.\";\r\n            requiredAction = \"exit\";\r\n            break;\r\n        default:\r\n            announcement = \"Unknown encounter!\";\r\n    }\r\n\r\n    // If userInput is null, it means this is the first time player has entered the room\r\n    if (userInput === null) {\r\n        announce(announcement);\r\n        return;\r\n    }\r\n\r\n    // If userInput matches the required action\r\n    if (userInput === requiredAction) {\r\n        switch (encounter) {\r\n            case 'diamond':\r\n            case 'emerald':\r\n            case 'gold':\r\n                score += 10; // Increment score as you deem fit\r\n                break;\r\n            // For trolls or other enemies, you might decrease health or handle other game mechanics\r\n        }\r\n\r\n        maze[y][x].encounter = null;  // Remove the encounter from the room\r\n        moveToCenter();               // Move hero to center of the room\r\n        duringEncounter = false;     // Clear the encounter flag\r\n        announce(`Successfully handled the ${encounter}.`); // Notify player\r\n    } else {\r\n        announce(\"Wrong action! Try again.\");\r\n    }\r\n}\r\n\r\nfunction getRandomInt(max) {\r\n    return Math.floor(Math.random() * max);\r\n}\r\n\r\nfunction getDistance(pos1, pos2) {\r\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\r\n}\r\n\r\nfunction renderMazeInConsole() {\r\n    let visualization = \"\";\r\n\r\n    for (let i = 0; i < mazeSize; i++) {\r\n        for (let j = 0; j < mazeSize; j++) {\r\n            if (j == 0) {\r\n                visualization += \"|\";\r\n            }\r\n\r\n            if (playerPosition.y == i && playerPosition.x == j) {\r\n                visualization += \" X \";\r\n            } else {\r\n                visualization += \"   \";\r\n            }\r\n\r\n            visualization += \"|\";\r\n        }\r\n        visualization += \"\\n\";\r\n        visualization += Array(mazeSize * 4 + 1).join(\"_\");\r\n        visualization += \"\\n\";\r\n    }\r\n\r\n    console.log(visualization);\r\n}\r\n\r\nfunction displayEncounter(room) {\r\n    // Clear any existing encounters from the previous room\r\n    $('#encounter').empty();\r\n\r\n    const encounterType = room.encounter;\r\n    if (encounterType && roomEncounter[encounterType]) {\r\n        $(\"#encounter\").append(roomEncounter[encounterType]);\r\n    }\r\n}\r\n\r\nfunction getExitCoordinates(data) {\r\n    for (let i = 0; i < data.mazeSize; i++) {\r\n        for (let j = 0; j < data.mazeSize; j++) {\r\n            if (data.rooms[i][j].encounter === \"exit\") {\r\n                return { x: j, y: i };\r\n            }\r\n        }\r\n    }\r\n    return null; // This will return null if no exit is found, but in a well-designed game, there should always be an exit.\r\n}\r\n\r\nfunction announce(message) {\r\n    $('#announcer').text(message);\r\n}\r\n\r\nfunction encounterAnnounce(message) {\r\n    $('#encounterAnnouncer').text(message);\r\n}\r\n\r\nfunction closeDoors() {\r\n    $('.doors').addClass('closed');\r\n}\r\n\r\nfunction openDoors() {\r\n    $('.doors').removeClass('closed');\r\n}"]}