{"version":3,"sources":["movement.js","script.js","tests.js","utilities.js"],"names":["movePlayer","direction","let","newX","playerPosition","x","newY","y","duringGame","canMoveTo","leaveRoomInDirection","roomsVisited","roomsTraveled","text","setTimeout","enterRoomFromDirection","announce","mazeSize","maze","doors","isEncounterInThatRoom","encounter","animationName","$","addClass","removeClass","moveToCenter","enterRoom","hero","fromClass","directionMap","fromNorthEncounter","fromSouthEncounter","fromEastEncounter","fromWestEncounter","hasClass","mazeData","score","duringEncounter","question","flagQuestion","enemyTimer","previousAnnouncement","directions","levelSelectWrapper","levelSelect","menuTrolls","menuHeader","scoreTotal","north","east","south","west","async","loadMaze","level","val","data","await","fetch","json","validationResult","validateMaze","isValid","initializeMaze","updateMazeVisualization","loadBackgroundImages","background","alert","message","error","backgroundSrc","i","append","rooms","mazeEnemies","Object","keys","enemies","mazeTreasures","treasures","exit","getExitCoordinates","setInitialPlayerPosition","clearInitialRoom","getRandomInt","getDistance","visited","handleUserInput","input","resetGame","hideMenuItems","toggleHelpModal","handleEncounterInput","handleFlagQuestionState","handleGameState","handleMenuState","handleQuestionState","includes","encounterAnnounce","insertFlag","color","setFlagInCurrentRoom","updateScore","displayFlag","flag","checkForFlag","remove","currentRoom","toggleClass","startEnemyTimer","numEnemies","setInterval","stopEnemyTimer","clearInterval","encounters","currentEncounter","Array","isArray","encounterData","action","victory","find","first","shift","remainingEnemies","filter","e","length","value","openDoors","handleEncounter","getEncounters","room","getCurrentRoom","announcement","gameOver","currentDoors","$maze","displayEncounter","empty","forEach","item","content","image","resetEncounterAnnouncer","handleRepeatedEntry","handleFirstTimeEntry","renderMazeInConsole","closeDoors","toggleGameOverClasses","add","cls","showMenuItems","show","removeBackgroundImages","not","attr","result","hasSingleExit","validateDoorIntegrity","isMazeSolvable","exitCount","exitLocations","row","j","push","console","log","join","rows","cols","exitLocation","col","from","fill","dfs","max","Math","floor","random","pos1","pos2","abs","hide","amount","visualization","on","keypress","which","this","toLowerCase"],"mappings":"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","file":"main.js","sourcesContent":["/**\n * Moves the player in the specified direction if possible.\n * @param {string} direction - The direction to move the player in (\"north\", \"south\", \"east\", \"west\").\n */\nfunction movePlayer(direction) {\n    let newX = playerPosition.x;\n    let newY = playerPosition.y;\n\n    if (!duringGame) {\n        announce(\"You must start the game first!\");\n        return;\n    }\n\n    switch (direction) {\n        case \"north\": newY--; break;\n        case \"south\": newY++; break;\n        case \"east\": newX++; break;\n        case \"west\": newX--; break;\n    }\n\n    if (canMoveTo(newX, newY, direction)) {\n        leaveRoomInDirection(direction);\n        roomsVisited++;\n        roomsTraveled.text(roomsVisited);\n        setTimeout(function () {\n            playerPosition.x = newX;\n            playerPosition.y = newY;\n            enterRoomFromDirection(direction);\n        }, 1000);\n    } else {\n        announce(\"You can't go that way!\");\n    }\n}\n\n/**\n * Checks if the player can move to the specified coordinates.\n * @param {number} x - The x-coordinate to move to.\n * @param {number} y - The y-coordinate to move to.\n * @param {string} direction - The direction to move in.\n * @returns {boolean} - Whether the player can move to the specified coordinates.\n */\nfunction canMoveTo(x, y, direction) {\n    return x >= 0 && y >= 0 && x < mazeSize && y < mazeSize && maze[playerPosition.y][playerPosition.x].doors[direction];\n}\n\n/**\n * Handles the player entering a room from a specific direction.\n * @param {string} direction - The direction from which the player is entering the room.\n */\nfunction enterRoomFromDirection(direction) {\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\n    let isEncounterInThatRoom = currentRoom.encounter !== null;\n    let animationName = '';\n\n    switch (direction) {\n        case \"north\":\n            animationName = isEncounterInThatRoom ? 'fromSouthEncounter' : 'arriveFromSouth';\n            break;\n        case \"south\":\n            animationName = isEncounterInThatRoom ? 'fromNorthEncounter' : 'arriveFromNorth';\n            break;\n        case \"east\":\n            animationName = isEncounterInThatRoom ? 'fromWestEncounter' : 'arriveFromWest';\n            break;\n        case \"west\":\n            animationName = isEncounterInThatRoom ? 'fromEastEncounter' : 'arriveFromEast';\n            break;\n    }\n\n    $('.hero').addClass(animationName);\n    // Wait for the animation to finish\n    setTimeout(function () {\n        // if it's an encounter, dont remove the animation class\n        if (!isEncounterInThatRoom) {\n            $('.hero').removeClass(animationName);\n            moveToCenter();\n        }\n    }, 1000);\n    enterRoom();\n}\n\n/**\n * Handles the player leaving a room in a specific direction.\n * @param {string} direction - The direction in which the player is leaving the room.\n */\nfunction leaveRoomInDirection(direction) {\n    let animationName = '';\n    switch (direction) {\n        case \"north\":\n            animationName = 'leaveToNorth';\n            break;\n        case \"south\":\n            animationName = 'leaveToSouth';\n            break;\n        case \"east\":\n            animationName = 'leaveToEast';\n            break;\n        case \"west\":\n            animationName = 'leaveToWest';\n            break;\n    }\n    $('.hero').addClass(animationName);\n    // Wait for the animation to finish\n    setTimeout(function () {\n        $('.hero').removeClass(animationName);\n    }, 1000);\n\n}\n\n/**\n * Moves the player to the center of the room after an encounter.\n */\nfunction moveToCenter() {\n    const hero = $('.hero');\n    const directionMap = {\n        'fromNorthEncounter': 'toCenterFromNorth',\n        'fromSouthEncounter': 'toCenterFromSouth',\n        'fromEastEncounter': 'toCenterFromEast',\n        'fromWestEncounter': 'toCenterFromWest',\n    };\n\n    for (let fromClass in directionMap) {\n        if (hero.hasClass(fromClass)) {\n            hero.addClass(directionMap[fromClass])\n                .removeClass(fromClass);\n            break;\n        }\n    }\n\n    // now after animation finishes after 1 sec remove the toCenter class\n    setTimeout(function () {\n        hero.removeClass('toCenterFromNorth toCenterFromSouth toCenterFromEast toCenterFromWest');\n    }, 1000);\n}","let mazeData = null;\r\n\r\n// Global variables\r\nlet playerPosition = { x: 0, y: 0 };\r\nlet score = 0;\r\nlet roomsVisited = 0;\r\nlet duringGame = false;\r\nlet duringEncounter = false;\r\nlet question = false;\r\nlet flagQuestion = false;\r\nlet enemyTimer; // to hold the interval for decrementing score due to enemies\r\n\r\n// Needed to store the previous announcement when the player is asked a question\r\nlet previousAnnouncement = null;\r\n\r\nconst directions = [\"north\", \"south\", \"east\", \"west\"];\r\n\r\n// html elements\r\nlet levelSelectWrapper = $('.maze__level-select');\r\nlet levelSelect = $('#level');\r\nlet menuTrolls = $('.dancing-troll');\r\nlet menuHeader = $('.menu__heading');\r\nlet scoreTotal = $('#score');\r\nlet roomsTraveled = $('#rooms');\r\n\r\nconst doors = {\r\n    north: '<span class=\"doors doors--north\"></span>',\r\n    east: '<span class=\"doors doors--east\"></span>',\r\n    south: '<span class=\"doors doors--south\"></span>',\r\n    west: '<span class=\"doors doors--west\"></span>'\r\n}\r\n\r\n// toggle help modal on click\r\n$('#closeModal').on('click', toggleHelpModal);\r\n\r\n// User input handling\r\n$(\"#userInput\").keypress(function (e) {\r\n    if (e.which === 13) { // Enter key pressed\r\n        let input = $(this).val().toLowerCase();\r\n        handleUserInput(input);\r\n        // clear the input field\r\n        $(this).val(\"\");\r\n    }\r\n});\r\n\r\n/**\r\n * Asynchronously loads the maze configuration based on the selected level.\r\n * Initializes the maze if the configuration is valid.\r\n */\r\nasync function loadMaze() {\r\n    const level = levelSelect.val();\r\n    try {\r\n        const response = await fetch(`./maze-configs/${level}.json`);\r\n        const data = await response.json();\r\n        const validationResult = validateMaze(data);\r\n        if (validationResult.isValid) {\r\n            mazeData = data;\r\n            initializeMaze(data);\r\n            updateMazeVisualization();\r\n            loadBackgroundImages(data.background);\r\n        } else {\r\n            alert(`Invalid maze configuration: ${validationResult.message}`);\r\n        }\r\n    } catch (error) {\r\n        alert('Failed to load maze.');\r\n    }\r\n}\r\n\r\n/**\r\n * Loads background images into the maze.\r\n * @param {string} backgroundSrc - The source URL of the background image.\r\n */\r\nfunction loadBackgroundImages(backgroundSrc) {\r\n    for (let i = 1; i <= 4; i++) {\r\n        $('#maze').append(`<img class=\"maze__menu-background maze__menu-background--${i}\" src=\"${backgroundSrc}\" alt=\"Background\">`);\r\n    }\r\n}\r\n\r\n/**\r\n * Initializes the maze variables and sets the initial player position.\r\n * @param {Object} data - The maze configuration data.\r\n */\r\nfunction initializeMaze(data) {\r\n    mazeSize = data.mazeSize;\r\n    maze = data.rooms;\r\n    mazeEnemies = Object.keys(data.enemies);\r\n    mazeTreasures = Object.keys(data.treasures);\r\n    exit = getExitCoordinates(data);\r\n    setInitialPlayerPosition();\r\n    clearInitialRoom();\r\n}\r\n\r\n/**\r\n * Sets the initial player position randomly, ensuring it is at least 3 units away from the exit.\r\n */\r\nfunction setInitialPlayerPosition() {\r\n    do {\r\n        playerPosition.x = getRandomInt(mazeSize);\r\n        playerPosition.y = getRandomInt(mazeSize);\r\n    } while (getDistance(playerPosition, exit) < 3);\r\n}\r\n\r\n/**\r\n * Clears any encounters in the initial room and marks it as visited.\r\n */\r\nfunction clearInitialRoom() {\r\n    maze[playerPosition.y][playerPosition.x].encounter = null;\r\n    maze[playerPosition.y][playerPosition.x].visited = true;\r\n}\r\n\r\n/**\r\n * Main function to handle user input. Delegates to specific handlers based on the game state.\r\n * @param {string} input - The user's input command.\r\n */\r\nfunction handleUserInput(input) {\r\n    // If a question is being asked, handle it first\r\n    if (question) {\r\n        handleQuestionState(input);\r\n        return; // Exit the function early\r\n    }\r\n\r\n    // Handle 'start' and 'help' commands at any point during the game\r\n    if (input === \"start\") {\r\n        if (duringGame) {\r\n            previousAnnouncement = $('#announcer').text();\r\n            announce(\"Do you want to return to the main menu? Type 'yes' or 'no'.\");\r\n            question = true;\r\n            return; // Exit the function early\r\n        } else {\r\n            duringGame = true;\r\n            resetGame();\r\n            hideMenuItems();\r\n            loadMaze();\r\n            announce(\"You are in a maze. Try to find the exit. Type 'help' for more instructions.\");\r\n            return; // Exit the function early\r\n        }\r\n    } else if (input === \"help\") {\r\n        toggleHelpModal();\r\n        return; // Exit the function early\r\n    }\r\n\r\n    // Existing logic for other states\r\n    if (!duringGame) {\r\n        handleMenuState(input);\r\n    } else if (duringGame && !duringEncounter && !question && !flagQuestion) {\r\n        handleGameState(input);\r\n    } else if (duringEncounter) {\r\n        handleEncounterInput(input);\r\n    } else if (flagQuestion) {\r\n        handleFlagQuestionState(input);\r\n    } else {\r\n        announce(\"Unknown command. Type 'help' for more instructions.\");\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Handles user input when the game is in the menu state.\r\n * @param {string} input - The user's input command.\r\n */\r\nfunction handleMenuState(input) {\r\n    if (input === \"start\") {\r\n        duringGame = true;\r\n        resetGame();\r\n        hideMenuItems();\r\n        loadMaze();\r\n        announce(\"You are in a maze. Try to find the exit. Type 'help' for more instructions.\");\r\n    } else if (input === \"help\") {\r\n        toggleHelpModal();\r\n    } else {\r\n        announce(\"Unknown command. Type 'help' for more instructions.\");\r\n    }\r\n}\r\n\r\n/**\r\n * Handles user input during the main game state, but not during encounters or questions.\r\n * @param {string} input - The user's input command.\r\n */\r\nfunction handleGameState(input) {\r\n    if (input === \"start\") {\r\n        previousAnnouncement = $('#announcer').text();\r\n        announce(\"Do you want to return to the main menu? Type 'yes' or 'no'.\");\r\n        question = true;\r\n    } else if (input === 'flag') {\r\n        previousAnnouncement = $('#announcer').text();\r\n        announce(\"Insert flag for 100 points. Pick color, type 'red', 'green', 'yellow' or 'cancel' to cancel.\");\r\n        flagQuestion = true;\r\n    } else if (directions.includes(input)) {\r\n        movePlayer(input);\r\n    } else {\r\n        announce(\"Unknown command. Type 'help' for more instructions.\");\r\n    }\r\n}\r\n\r\n/**\r\n * Handles user input when a yes/no question is being asked.\r\n * @param {string} input - The user's input command.\r\n */\r\nfunction handleQuestionState(input) {\r\n    if (input === \"yes\") {\r\n        duringGame = false;\r\n        duringEncounter = false;\r\n        question = false;\r\n        resetGame();\r\n        announce(\"Game has been reset. Type 'start' to begin again.\");\r\n    } else if (input === \"no\") {\r\n        question = false;\r\n        announce(previousAnnouncement);\r\n    } else {\r\n        encounterAnnounce(\"Please answer with 'yes' or 'no'.\");\r\n    }\r\n}\r\n\r\n/**\r\n * Handles user input when the player is asked to insert a flag.\r\n * @param {string} input - The user's input command.\r\n */\r\nfunction handleFlagQuestionState(input) {\r\n    if (input === 'red' || input === 'green' || input === 'yellow') {\r\n        insertFlag(input);\r\n    } else if (input === 'cancel') {\r\n        flagQuestion = false;\r\n        announce(previousAnnouncement);\r\n    } else {\r\n        announce(\"Unknown flag color. Type 'red', 'green', 'yellow' or 'cancel' to cancel.\");\r\n    }\r\n}\r\n\r\n/**\r\n * Inserts a flag of the given color into the current room, updates the score, and displays the flag.\r\n * @param {string} color - The color of the flag to insert.\r\n */\r\nfunction insertFlag(color) {\r\n    setFlagInCurrentRoom(color);\r\n    updateScore(-100);\r\n    displayFlag(color);\r\n    flagQuestion = false;\r\n    encounterAnnounce(`${color} flag set in this room!`);\r\n    announce(previousAnnouncement);\r\n}\r\n\r\n/**\r\n * Sets a flag of the given color in the current room.\r\n * @param {string} color - The color of the flag to set.\r\n */\r\nfunction setFlagInCurrentRoom(color) {\r\n    maze[playerPosition.y][playerPosition.x].flag = `${color}-flag`;\r\n}\r\n\r\n/**\r\n * Displays a flag of the given color in the maze.\r\n * @param {string} color - The color of the flag to display.\r\n */\r\nfunction displayFlag(color) {\r\n    $('#maze').append(`<img class=\"flag\" src=\"./dist/assets/flags/${color}-flag.jpg\" alt=\"Flag\">`);\r\n}\r\n\r\n/**\r\n * Checks for the presence of a flag in the current room and displays it if found.\r\n */\r\nfunction checkForFlag() {\r\n    $('.flag').remove();\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    if (currentRoom.flag) {\r\n        $('#maze').append(`<img class=\"flag\" src=\"./dist/assets/flags/${currentRoom.flag}.jpg\" alt=\"Flag\">`);\r\n    }\r\n}\r\n\r\n/**\r\n * Toggles the visibility of the help modal.\r\n */\r\nfunction toggleHelpModal() {\r\n    $('.help-modal').toggleClass('hidden');\r\n}\r\n\r\n/**\r\n * Starts a timer that decrements the player's score based on the number of enemies.\r\n * @param {number} numEnemies - The number of enemies in the room.\r\n */\r\nfunction startEnemyTimer(numEnemies) {\r\n    const decrementScore = () => {\r\n        updateScore(-100 * numEnemies);\r\n        if (score <= 0) {\r\n            stopEnemyTimer();\r\n            updateScore(0);\r\n        }\r\n    };\r\n    enemyTimer = setInterval(decrementScore, 2000);\r\n}\r\n\r\n/**\r\n * Stops the enemy timer, halting the decrement of the player's score.\r\n */\r\nfunction stopEnemyTimer() {\r\n    clearInterval(enemyTimer);\r\n}\r\n\r\n/**\r\n * Handles user input during an encounter with an enemy, treasure, or exit.\r\n * @param {string} input - The user's input command.\r\n */\r\nfunction handleEncounterInput(input) {\r\n    if (!duringEncounter) return;\r\n\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    let encounters = currentRoom.encounter;\r\n\r\n    if (!encounters) return;\r\n\r\n    encounters = Array.isArray(encounters) ? encounters : [encounters];\r\n    const currentEncounter = encounters[0];\r\n\r\n    let encounterData;\r\n    if (mazeData.enemies[currentEncounter]) {\r\n        encounterData = mazeData.enemies[currentEncounter];\r\n    } else if (mazeData.treasures[currentEncounter]) {\r\n        encounterData = mazeData.treasures[currentEncounter];\r\n    } else if (currentEncounter === \"exit\") {\r\n        encounterData = { action: 'exit', victory: `You've found the exit! Congratulations.` };\r\n    }\r\n\r\n    if (input === encounterData.action) {\r\n        encounterAnnounce(encounterData.victory);\r\n\r\n        // Stop the existing enemy timer\r\n        clearInterval(enemyTimer);\r\n\r\n        // Add 'defeated' class to the next non-defeated image\r\n        $(\"#encounter\").find(\"img:not(.defeated)\").first().addClass('defeated');\r\n\r\n        encounters.shift(); // Remove the handled encounter\r\n\r\n        const remainingEnemies = encounters.filter(e => mazeEnemies.includes(e)).length;\r\n\r\n        if (remainingEnemies > 0) {\r\n            startEnemyTimer(remainingEnemies);\r\n        }\r\n\r\n        if (mazeData.treasures[currentEncounter]) {\r\n            updateScore(mazeData.treasures[currentEncounter].value);\r\n        }\r\n\r\n        if (encounters.length === 0) {\r\n            announce(\"Room cleared! Move on to the next room.\");\r\n            currentRoom.encounter = null;\r\n            duringEncounter = false;\r\n            stopEnemyTimer();  // Stop decrementing score due to enemies\r\n            moveToCenter();\r\n            openDoors();\r\n        } else {\r\n            // Update the timer for remaining enemies\r\n            stopEnemyTimer();\r\n            startEnemyTimer(remainingEnemies);\r\n            // Otherwise, proceed to the next encounter in the list\r\n            handleEncounter();\r\n        }\r\n    } else {\r\n        encounterAnnounce(\"Wrong action! Try again.\");\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the encounters in the given room as an array.\r\n * @param {object} room - The room to check for encounters.\r\n * @returns {array} - The encounters in the room.\r\n */\r\nfunction getEncounters(room) {\r\n    return Array.isArray(room.encounter) ? room.encounter : [room.encounter];\r\n}\r\n\r\n/**\r\n * Returns the current room the player is in.\r\n * @returns {object} - The current room.\r\n */\r\nfunction getCurrentRoom() {\r\n    return maze[playerPosition.y][playerPosition.x];\r\n}\r\n\r\n/**\r\n * Handles the encounter logic for the current room, announcing what the player has encountered.\r\n */\r\nfunction handleEncounter() {\r\n    const currentRoom = getCurrentRoom();\r\n    const encounters = getEncounters(currentRoom);\r\n    const currentEncounter = encounters[0];\r\n\r\n    let announcement = '';\r\n\r\n    if (mazeEnemies.includes(currentEncounter)) {\r\n        announcement = mazeData.enemies[currentEncounter].announcement;\r\n    } else if (mazeTreasures.includes(currentEncounter)) {\r\n        announcement = mazeData.treasures[currentEncounter].announcement;\r\n    } else if (currentEncounter === 'exit') {\r\n        announcement = \"You've found the exit! Congratulations.\";\r\n        gameOver();\r\n    }\r\n\r\n    if (announcement) {\r\n        announce(announcement);\r\n    }\r\n}\r\n\r\n/**\r\n * Updates the maze visualization by displaying available doors in the current room.\r\n */\r\nfunction updateMazeVisualization() {\r\n    // Clear any existing door elements from the previous room\r\n    $('.doors').remove();\r\n\r\n    // Fetch the current room based on player's position\r\n    const { doors: currentDoors } = maze[playerPosition.y][playerPosition.x];\r\n\r\n    // Check for available doors and inject them into the maze\r\n    const $maze = $(\"#maze\");\r\n    for (const direction in currentDoors) {\r\n        if (currentDoors[direction]) {\r\n            $maze.append(doors[direction]);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Displays the encounters (enemies, treasures, or exit) in the current room.\r\n * @param {object} room - The current room.\r\n */\r\nfunction displayEncounter(room) {\r\n    $('#encounter').empty();\r\n    if (room.encounter) {\r\n        const encounters = Array.isArray(room.encounter) ? room.encounter : [room.encounter];\r\n\r\n        encounters.forEach(item => {\r\n            let content = '';\r\n            if (mazeEnemies.includes(item)) {\r\n                content = mazeData.enemies[item].image;\r\n                content = `<div class=\"enemy--wrapper\">${content}</div>`;\r\n            } else if (mazeTreasures.includes(item)) {\r\n                content = mazeData.treasures[item].image;\r\n            } else if (item === \"exit\") {\r\n                content = '<img src=\"./dist/assets/exit.png\" alt=\"Exit\">';\r\n            }\r\n\r\n            $(\"#encounter\").append(content);\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Handles the logic for entering a room, including encounters and updates.\r\n */\r\nfunction enterRoom() {\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    resetEncounterAnnouncer();\r\n\r\n    if (!currentRoom.visited && currentRoom.encounter !== null) {\r\n        handleFirstTimeEntry(currentRoom);\r\n    } else {\r\n        handleRepeatedEntry(currentRoom);\r\n    }\r\n\r\n    renderMazeInConsole();\r\n    displayEncounter(currentRoom);\r\n}\r\n\r\n/**\r\n * Resets the encounter announcer to its default state.\r\n */\r\nfunction resetEncounterAnnouncer() {\r\n    encounterAnnounce(\"\");\r\n}\r\n\r\n/**\r\n * Handles the logic for the first time a player enters a room.\r\n * @param {object} currentRoom - The room the player is entering for the first time.\r\n */\r\nfunction handleFirstTimeEntry(currentRoom) {\r\n    $('.flag').remove();  // Remove flag img from the room if arrived from room where you set one\r\n    currentRoom.visited = true;  // Mark the room as visited\r\n    updateMazeVisualization();  // Update the maze visualization\r\n    duringEncounter = true;  // Initiate encounter state\r\n\r\n    setTimeout(() => closeDoors(), 1000);  // After 1 sec close doors\r\n    handleEncounter();  // Handle the encounter\r\n\r\n    setTimeout(() => $('.enemy--wrapper').addClass('fight'), 2000);  // After 2 sec add class 'fight' to elements .enemy--wrapper\r\n\r\n    const numEnemies = Array.isArray(currentRoom.encounter)\r\n        ? currentRoom.encounter.filter(e => mazeEnemies.includes(e)).length\r\n        : mazeEnemies.includes(currentRoom.encounter) ? 1 : 0;\r\n\r\n    if (numEnemies > 0) startEnemyTimer(numEnemies);\r\n}\r\n\r\n/**\r\n * Handles the logic for when a player re-enters a room.\r\n * @param {object} currentRoom - The room the player is re-entering.\r\n */\r\nfunction handleRepeatedEntry(currentRoom) {\r\n    announce(\"Nothing in this room\");\r\n    updateMazeVisualization();\r\n    checkForFlag();\r\n}\r\n\r\nfunction toggleGameOverClasses(add) {\r\n    const classes = ['hero', 'maze__score', 'maze__rooms'];\r\n    classes.forEach(cls => $(`.${cls}`).toggleClass('game-over', add));\r\n}\r\n\r\n/**\r\n * Shows the menu items that are hidden during the game.\r\n */\r\nfunction showMenuItems() {\r\n    menuTrolls.show();\r\n    levelSelectWrapper.show();\r\n    menuHeader.show();\r\n}\r\n\r\n/**\r\n * Removes the background images, except for the dancing troll.\r\n */\r\nfunction removeBackgroundImages() {\r\n    $('.maze__menu-background').not('.dancing-troll').remove();\r\n}\r\n\r\n/**\r\n * Handles the game over state, including UI updates.\r\n */\r\nfunction gameOver() {\r\n    duringGame = false;\r\n    duringEncounter = false;\r\n\r\n    showMenuItems();\r\n    toggleGameOverClasses(true);\r\n    removeBackgroundImages();\r\n\r\n    encounterAnnounce(\"Type start to play again.\");\r\n}\r\n\r\n/**\r\n * Resets the game to its initial state.\r\n */\r\nfunction resetGame() {\r\n    showMenuItems();\r\n    $('.doors').remove();  // Remove all .doors elements\r\n    toggleGameOverClasses(false);\r\n    removeBackgroundImages();\r\n\r\n    // Remove other classes from the hero element apart from .hero\r\n    $('.hero').attr('class', 'hero');\r\n\r\n    // Remove all images from the #encounter container\r\n    $('#encounter').empty();\r\n\r\n    //cler encounter announcer\r\n    resetEncounterAnnouncer();\r\n\r\n    // Unload Maze\r\n    maze = null;\r\n    mazeData = null;\r\n    playerPosition = { x: 0, y: 0 };\r\n    score = 0;\r\n    roomsVisited = 0;\r\n    scoreTotal.text(score);\r\n    roomsTraveled.text(roomsVisited);\r\n}\r\n","/**\n * Validates the integrity and solvability of the maze.\n * @param {Object} data - The maze data.\n * @returns {Object} - An object containing a boolean indicating validity and a message string.\n */\nfunction validateMaze(data) {\n    let result = { isValid: true, message: '' };\n\n    if (!hasSingleExit(data)) {\n        result.isValid = false;\n        result.message = 'Maze must have exactly one exit.';\n        return result;\n    }\n\n    if (!validateDoorIntegrity(data)) {\n        result.isValid = false;\n        result.message = 'Some rooms have doors that lead to nowhere.';\n        return result;\n    }\n\n    if (!isMazeSolvable(data)) {\n        result.isValid = false;\n        result.message = 'The maze is not solvable from every room.';\n        return result;\n    }\n\n    return result;\n}\n\n/**\n * Checks if the maze has exactly one exit.\n * @param {Object} data - The maze data.\n * @returns {boolean} - True if there's exactly one exit, false otherwise.\n */\nfunction hasSingleExit(data) {\n    let exitCount = 0;\n    let exitLocations = [];\n\n    for (let i = 0; i < data.rooms.length; i++) {\n        const row = data.rooms[i];\n        for (let j = 0; j < row.length; j++) {\n            const room = row[j];\n            if (room.encounter === \"exit\") {\n                exitCount++;\n                exitLocations.push(`row ${i + 1}, column ${j + 1}`);\n            }\n        }\n    }\n\n    if (exitCount !== 1) {\n        console.log(`Invalid number of exits: ${exitCount}. Exits found at ${exitLocations.join(', ')}.`);\n    }\n\n    return exitCount === 1;\n}\n\n/**\n * Validates that all doors in the maze lead to another room with a matching door.\n * @param {Object} data - The maze data.\n * @returns {boolean} - True if all doors are valid, false otherwise.\n */\nfunction validateDoorIntegrity(data) {\n    const rows = data.rooms.length;\n    const cols = data.rooms[0].length;\n\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            const room = data.rooms[i][j];\n            const doors = room.doors;\n\n            if (doors.north && (i === 0 || !data.rooms[i - 1][j].doors.south)) {\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the north doesn't match.`);\n                return false;\n            }\n            if (doors.south && (i === rows - 1 || !data.rooms[i + 1][j].doors.north)) {\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the south doesn't match.`);\n                return false;\n            }\n            if (doors.east && (j === cols - 1 || !data.rooms[i][j + 1].doors.west)) {\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the east doesn't match.`);\n                return false;\n            }\n            if (doors.west && (j === 0 || !data.rooms[i][j - 1].doors.east)) {\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the west doesn't match.`);\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks if the maze is solvable from every room.\n * @param {Object} data - The maze data.\n * @returns {boolean} - True if the maze is solvable, false otherwise.\n */\nfunction isMazeSolvable(data) {\n    const rows = data.rooms.length;\n    const cols = data.rooms[0].length;\n    let exitLocation = null;\n\n    // Find the exit location\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (data.rooms[i][j].encounter === \"exit\") {\n                exitLocation = { row: i, col: j };\n                break;\n            }\n        }\n        if (exitLocation) break;\n    }\n\n    // Depth-first search function to explore the maze\n    function dfs(row, col, visited) {\n        if (row < 0 || row >= rows || col < 0 || col >= cols || visited[row][col]) {\n            return false;\n        }\n\n        if (row === exitLocation.row && col === exitLocation.col) {\n            return true;\n        }\n\n        visited[row][col] = true;\n\n        const doors = data.rooms[row][col].doors;\n\n        return (doors.north && dfs(row - 1, col, visited)) ||\n            (doors.south && dfs(row + 1, col, visited)) ||\n            (doors.east && dfs(row, col + 1, visited)) ||\n            (doors.west && dfs(row, col - 1, visited));\n    }\n\n    // Check solvability from each room\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            const visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n            if (!dfs(i, j, visited)) {\n                console.log(`Maze is not solvable from row ${i + 1}, column ${j + 1}.`);\n                return false;\n            }\n        }\n    }\n\n    return true;\n}","/**\n * Updates the main announcer with a given message.\n * @param {string} message - The message to display.\n */\nfunction announce(message) {\n    $('#announcer').text(message);\n}\n\n/**\n * Updates the encounter announcer with a given message.\n * Encounter announcer is the one on the bottom of the screen.\n * @param {string} message - The message to display.\n */\nfunction encounterAnnounce(message) {\n    $('#encounterAnnouncer').text(message);\n}\n\n/**\n * Closes all doors in the current room by adding the 'closed' class.\n */\nfunction closeDoors() {\n    $('.doors').addClass('closed');\n}\n\n/**\n * Opens all doors in the current room by removing the 'closed' class.\n */\nfunction openDoors() {\n    $('.doors').removeClass('closed');\n}\n\n/**\n * Generates a random integer between 0 and the given maximum (exclusive).\n * @param {number} max - The maximum value.\n * @returns {number} - A random integer.\n */\nfunction getRandomInt(max) {\n    return Math.floor(Math.random() * max);\n}\n\n/**\n * Calculates the Manhattan distance between two positions.\n * @param {Object} pos1 - The first position.\n * @param {Object} pos2 - The second position.\n * @returns {number} - The so called Manhattan distance.\n */\nfunction getDistance(pos1, pos2) {\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\n}\n\n/**\n * Hides menu items by setting their visibility to hidden.\n */\nfunction hideMenuItems() {\n    menuTrolls.hide();\n    levelSelectWrapper.hide();\n    menuHeader.hide();\n\n}\n\n/**\n * Updates the player's score by a given amount.\n * @param {number} amount - The amount to update the score by.\n */\nfunction updateScore(amount) {\n    score += amount;\n\n    // Ensure the score doesn't go below zero\n    if (score < 0) {\n        score = 0;\n    }\n\n    // Update the score display\n    scoreTotal.text(score);\n}\n\n/**\n * Finds and returns the coordinates of the exit in the maze.\n * @param {Object} data - The maze data.\n * @returns {Object|null} - The coordinates of the exit or null if not found.\n */\nfunction getExitCoordinates(data) {\n    for (let i = 0; i < data.mazeSize; i++) {\n        for (let j = 0; j < data.mazeSize; j++) {\n            if (data.rooms[i][j].encounter === \"exit\") {\n                return { x: j, y: i };\n            }\n        }\n    }\n    return null; // Should never happen if it passes the validation but just in case.\n}\n\n/**\n * Renders a simple text-based visualization of the maze in the console.\n * Mainly for debugging purposes.\n * Kinda cheating if user knows about it but it's not like it's a part of the game.\n */\nfunction renderMazeInConsole() {\n    let visualization = \"\";\n\n    for (let i = 0; i < mazeSize; i++) {\n        for (let j = 0; j < mazeSize; j++) {\n            if (j == 0) {\n                visualization += \"|\";\n            }\n\n            if (playerPosition.y == i && playerPosition.x == j) {\n                visualization += \" X \";\n            } else {\n                visualization += \"   \";\n            }\n\n            visualization += \"|\";\n        }\n        visualization += \"\\n\";\n        visualization += Array(mazeSize * 4 + 1).join(\"_\");\n        visualization += \"\\n\";\n    }\n\n    console.log(visualization);\n}"]}