{"version":3,"sources":["movement.js","script.js"],"names":["enterRoomFromDirection","direction","let","isEncounterInThatRoom","maze","playerPosition","y","x","encounter","animationName","$","addClass","setTimeout","removeClass","moveToCenter","enterRoom","leaveRoomInDirection","hero","fromClass","directionMap","fromNorthEncounter","fromSouthEncounter","fromEastEncounter","fromWestEncounter","hasClass","mazeData","score","roomsVisited","duringGame","duringEncounter","question","flagQuestion","enemyTimer","previousAnnouncement","directions","levelSelectWrapper","levelSelect","menuTrolls","menuHeader","scoreTotal","roomsTraveled","doors","north","east","south","west","loadMaze","level","val","ajax","url","type","dataType","success","data","validationResult","validateMaze","isValid","initializeMaze","updateMazeVisualization","loadBackgroundImages","background","alert","message","error","result","hasSingleExit","validateDoorIntegrity","isMazeSolvable","exitCount","exitLocations","i","rooms","length","row","j","push","console","log","join","rows","cols","exitLocation","col","visited","Array","from","fill","dfs","backgroundSrc","loadedBackgroundImg","append","last","hideMenuItems","hide","mazeSize","mazeEnemies","Object","keys","enemies","mazeTreasures","treasures","exit","getExitCoordinates","getRandomInt","getDistance","handleUserInput","input","toggleHelpModal","text","announce","insertFlag","resetGame","encounterAnnounce","includes","movePlayer","handleEncounterInput","color","flag","updateScore","checkForFlag","remove","currentRoom","amount","toggleClass","startEnemyTimer","numEnemies","setInterval","clearInterval","stopEnemyTimer","encounters","currentEncounter","isArray","encounterData","action","victory","find","first","shift","remainingEnemies","filter","e","value","openDoors","handleEncounter","newX","newY","canMoveTo","closeDoors","renderMazeInConsole","displayEncounter","announcement","gameOver","show","not","max","Math","floor","random","pos1","pos2","abs","visualization","room","empty","forEach","item","content","image","attr","on","keypress","which","this","toLowerCase"],"mappings":"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","file":"main.js","sourcesContent":["\nfunction enterRoomFromDirection(direction) {\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\n    let isEncounterInThatRoom = currentRoom.encounter !== null;\n    let animationName = '';\n\n    switch (direction) {\n        case \"north\":\n            animationName = isEncounterInThatRoom ? 'fromSouthEncounter' : 'arriveFromSouth';\n            break;\n        case \"south\":\n            animationName = isEncounterInThatRoom ? 'fromNorthEncounter' : 'arriveFromNorth';\n            break;\n        case \"east\":\n            animationName = isEncounterInThatRoom ? 'fromWestEncounter' : 'arriveFromWest';\n            break;\n        case \"west\":\n            animationName = isEncounterInThatRoom ? 'fromEastEncounter' : 'arriveFromEast';\n            break;\n    }\n\n    $('.hero').addClass(animationName);\n    // Wait for the animation to finish\n    setTimeout(function () {\n        // if it's an encounter, dont remove the animation class\n        if (!isEncounterInThatRoom) {\n            $('.hero').removeClass(animationName);\n            moveToCenter();\n        }\n    }, 1000);\n    enterRoom();\n}\n\nfunction leaveRoomInDirection(direction) {\n    let animationName = '';\n    switch (direction) {\n        case \"north\":\n            animationName = 'leaveToNorth';\n            break;\n        case \"south\":\n            animationName = 'leaveToSouth';\n            break;\n        case \"east\":\n            animationName = 'leaveToEast';\n            break;\n        case \"west\":\n            animationName = 'leaveToWest';\n            break;\n    }\n    $('.hero').addClass(animationName);\n    // Wait for the animation to finish\n    setTimeout(function () {\n        $('.hero').removeClass(animationName);\n    }, 1000);\n\n}\n\nfunction moveToCenter() {\n    const hero = $('.hero');\n    const directionMap = {\n        'fromNorthEncounter': 'toCenterFromNorth',\n        'fromSouthEncounter': 'toCenterFromSouth',\n        'fromEastEncounter': 'toCenterFromEast',\n        'fromWestEncounter': 'toCenterFromWest',\n    };\n\n    for (let fromClass in directionMap) {\n        if (hero.hasClass(fromClass)) {\n            hero.addClass(directionMap[fromClass])\n                .removeClass(fromClass);\n            break;\n        }\n    }\n\n    // now after animation finishes after 1 sec remove the toCenter class\n    setTimeout(function () {\n        hero.removeClass('toCenterFromNorth toCenterFromSouth toCenterFromEast toCenterFromWest');\n    }, 1000);\n}","let mazeData = null;\r\n\r\n// Global variables\r\nlet playerPosition = { x: 0, y: 0 };\r\nlet score = 0;\r\nlet roomsVisited = 0;\r\nlet duringGame = false;\r\nlet duringEncounter = false;\r\nlet question = false;\r\nlet flagQuestion = false;\r\nlet enemyTimer; // to hold the interval for decrementing score due to enemies\r\n\r\n// Needed to store the previous announcement when the player is asked a question\r\nlet previousAnnouncement = null;\r\n\r\nconst directions = [\"north\", \"south\", \"east\", \"west\"];\r\n\r\n// html elements\r\nlet levelSelectWrapper = $('.maze__level-select');\r\nlet levelSelect = $('#level');\r\nlet menuTrolls = $('.dancing-troll');\r\nlet menuHeader = $('.menu__heading');\r\nlet scoreTotal = $('#score');\r\nlet roomsTraveled = $('#rooms');\r\n\r\nconst doors = {\r\n    north: '<span class=\"doors doors--north\"></span>',\r\n    east: '<span class=\"doors doors--east\"></span>',\r\n    south: '<span class=\"doors doors--south\"></span>',\r\n    west: '<span class=\"doors doors--west\"></span>'\r\n}\r\n\r\n// toggle help modal on click\r\n$('#closeModal').on('click', toggleHelpModal);\r\n\r\n// User input handling\r\n$(\"#userInput\").keypress(function (e) {\r\n    if (e.which === 13) { // Enter key pressed\r\n        let input = $(this).val().toLowerCase();\r\n        handleUserInput(input);\r\n        // clear the input field\r\n        $(this).val(\"\");\r\n    }\r\n});\r\n\r\nfunction loadMaze() {\r\n    let level = levelSelect.val();\r\n\r\n    $.ajax({\r\n        url: './maze-configs/' + level + '.json',\r\n        type: 'GET',\r\n        dataType: 'json',\r\n        success: function (data) {\r\n            const validationResult = validateMaze(data);\r\n            if (validationResult.isValid) {\r\n                mazeData = data;\r\n                initializeMaze(data);\r\n                updateMazeVisualization();\r\n\r\n                // Load the background images\r\n                loadBackgroundImages(data.background);\r\n            } else {\r\n                alert(`Invalid maze configuration: ${validationResult.message}`);\r\n            }\r\n        },\r\n        error: function () {\r\n            alert('Failed to load maze.');\r\n        }\r\n    });\r\n}\r\n\r\nfunction validateMaze(data) {\r\n    let result = { isValid: true, message: '' };\r\n\r\n    if (!hasSingleExit(data)) {\r\n        result.isValid = false;\r\n        result.message = 'Maze must have exactly one exit.';\r\n        return result;\r\n    }\r\n\r\n    if (!validateDoorIntegrity(data)) {\r\n        result.isValid = false;\r\n        result.message = 'Some rooms have doors that lead to nowhere.';\r\n        return result;\r\n    }\r\n\r\n    if (!isMazeSolvable(data)) {\r\n        result.isValid = false;\r\n        result.message = 'The maze is not solvable from every room.';\r\n        return result;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction hasSingleExit(data) {\r\n    let exitCount = 0;\r\n    let exitLocations = [];\r\n\r\n    for (let i = 0; i < data.rooms.length; i++) {\r\n        const row = data.rooms[i];\r\n        for (let j = 0; j < row.length; j++) {\r\n            const room = row[j];\r\n            if (room.encounter === \"exit\") {\r\n                exitCount++;\r\n                exitLocations.push(`row ${i + 1}, column ${j + 1}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (exitCount !== 1) {\r\n        console.log(`Invalid number of exits: ${exitCount}. Exits found at ${exitLocations.join(', ')}.`);\r\n    }\r\n\r\n    return exitCount === 1;\r\n}\r\n\r\nfunction validateDoorIntegrity(data) {\r\n    const rows = data.rooms.length;\r\n    const cols = data.rooms[0].length;\r\n\r\n    for (let i = 0; i < rows; i++) {\r\n        for (let j = 0; j < cols; j++) {\r\n            const room = data.rooms[i][j];\r\n            const doors = room.doors;\r\n\r\n            if (doors.north && (i === 0 || !data.rooms[i - 1][j].doors.south)) {\r\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the north doesn't match.`);\r\n                return false;\r\n            }\r\n            if (doors.south && (i === rows - 1 || !data.rooms[i + 1][j].doors.north)) {\r\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the south doesn't match.`);\r\n                return false;\r\n            }\r\n            if (doors.east && (j === cols - 1 || !data.rooms[i][j + 1].doors.west)) {\r\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the east doesn't match.`);\r\n                return false;\r\n            }\r\n            if (doors.west && (j === 0 || !data.rooms[i][j - 1].doors.east)) {\r\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the west doesn't match.`);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction isMazeSolvable(data) {\r\n    const rows = data.rooms.length;\r\n    const cols = data.rooms[0].length;\r\n    let exitLocation = null;\r\n\r\n    // Find the exit location\r\n    for (let i = 0; i < rows; i++) {\r\n        for (let j = 0; j < cols; j++) {\r\n            if (data.rooms[i][j].encounter === \"exit\") {\r\n                exitLocation = { row: i, col: j };\r\n                break;\r\n            }\r\n        }\r\n        if (exitLocation) break;\r\n    }\r\n\r\n    // Depth-first search function to explore the maze\r\n    function dfs(row, col, visited) {\r\n        if (row < 0 || row >= rows || col < 0 || col >= cols || visited[row][col]) {\r\n            return false;\r\n        }\r\n\r\n        if (row === exitLocation.row && col === exitLocation.col) {\r\n            return true;\r\n        }\r\n\r\n        visited[row][col] = true;\r\n\r\n        const doors = data.rooms[row][col].doors;\r\n\r\n        return (doors.north && dfs(row - 1, col, visited)) ||\r\n            (doors.south && dfs(row + 1, col, visited)) ||\r\n            (doors.east && dfs(row, col + 1, visited)) ||\r\n            (doors.west && dfs(row, col - 1, visited));\r\n    }\r\n\r\n    // Check solvability from each room\r\n    for (let i = 0; i < rows; i++) {\r\n        for (let j = 0; j < cols; j++) {\r\n            const visited = Array.from({ length: rows }, () => Array(cols).fill(false));\r\n            if (!dfs(i, j, visited)) {\r\n                console.log(`Maze is not solvable from row ${i + 1}, column ${j + 1}.`);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction loadBackgroundImages(backgroundSrc) {\r\n    // Load the background images\r\n    let loadedBackgroundImg = '<img class=\"maze__menu-background\" src=\"' + backgroundSrc + '\" alt=\"Background\">';\r\n\r\n    // create 4 copies of the background image, add class maze__menu-background-- + number to each and append to #maze\r\n    for (let i = 1; i < 5; i++) {\r\n        $('#maze').append(loadedBackgroundImg);\r\n        $('.maze__menu-background').last().addClass('maze__menu-background--' + i);\r\n    }\r\n}\r\n\r\nfunction hideMenuItems() {\r\n    menuTrolls.hide();\r\n    levelSelectWrapper.hide();\r\n    menuHeader.hide();\r\n\r\n}\r\n\r\nfunction initializeMaze(data) {\r\n    mazeSize = data.mazeSize;\r\n    maze = data.rooms;\r\n    mazeEnemies = Object.keys(data.enemies);  // get enemy keys\r\n    mazeTreasures = Object.keys(data.treasures);  // get treasure keys\r\n    exit = getExitCoordinates(data);\r\n\r\n    for (let i = 0; i < mazeSize; i++) {\r\n        for (let j = 0; j < mazeSize; j++) {\r\n            maze[i][j].visited = false;\r\n        }\r\n    }\r\n\r\n    do {\r\n        playerPosition.x = getRandomInt(mazeSize);\r\n        playerPosition.y = getRandomInt(mazeSize);\r\n    } while (getDistance(playerPosition, exit) < 3);\r\n\r\n    // Clear the encounter in the initial room\r\n    maze[playerPosition.y][playerPosition.x].encounter = null;\r\n    maze[playerPosition.y][playerPosition.x].visited = true;\r\n}\r\n\r\nfunction handleUserInput(input) {\r\n\r\n    if (input === \"start\" && !duringGame) {\r\n        duringGame = true;\r\n        resetGame();\r\n        hideMenuItems();\r\n        loadMaze();\r\n        announce(\"You are in a maze. Try to find the exit. Type 'help' for more instructions.\");\r\n    } else if (input === \"help\") {\r\n        toggleHelpModal();\r\n    } else if (input === \"start\" && duringGame) {\r\n        previousAnnouncement = $('#announcer').text();\r\n        announce(\"Do you want to return to the main menu? Type 'yes' or 'no'.\");\r\n        question = true;\r\n    } else if (input === 'flag' && !duringEncounter) {\r\n        previousAnnouncement = $('#announcer').text();\r\n        announce(\"Insert flag for 100 points. Pick color, type 'red', 'green', 'yellow' or 'cancel' to cancel.\");\r\n        flagQuestion = true;\r\n    } else if (flagQuestion) {\r\n        if (input === 'red' || input === 'green' || input === 'yellow') {\r\n            // set flag\r\n            insertFlag(input);\r\n        } else if (input === 'cancel') {\r\n            // cancel flag setting\r\n            flagQuestion = false;\r\n            announce(previousAnnouncement);\r\n        } else {\r\n            announce(\"Unknown flag color. Type 'red', 'green', 'yellow' or 'cancel' to cancel.\");\r\n        }\r\n    } else if (question) {\r\n        if (input === \"yes\") {\r\n            // Reset everything\r\n            duringGame = false;\r\n            duringEncounter = false;\r\n            question = false;\r\n            resetGame();\r\n            announce(\"Game has been reset. Type 'start' to begin again.\");\r\n        } else if (input === \"no\") {\r\n            // Continue game\r\n            question = false;\r\n            announce(previousAnnouncement);\r\n        } else {\r\n            encounterAnnounce(\"Please answer with 'yes' or 'no'.\");\r\n        }\r\n    } else if (directions.includes(input)) {\r\n        // Check if the player is during an encounter. If so, notify them and prevent movement.\r\n        if (duringEncounter) {\r\n            encounterAnnounce(\"You can't leave until you've dealt with the encounter!\");\r\n        } else {\r\n            movePlayer(input);\r\n        }\r\n    } else if (duringEncounter) {\r\n        // Handle the encounter input\r\n        handleEncounterInput(input);\r\n    } else {\r\n        announce(\"Unknown command. Type 'help' for more instructions.\");\r\n    }\r\n}\r\n\r\nfunction insertFlag(color) {\r\n    // set current room encounter to red flag\r\n    maze[playerPosition.y][playerPosition.x].flag = color + '-flag';\r\n    flagQuestion = false;\r\n\r\n    // deduct 100 from score and show new score\r\n    updateScore(-100);\r\n\r\n    encounterAnnounce(color + \" flag set in this room!\");\r\n    announce(previousAnnouncement);\r\n    // add flag img to the room\r\n    $('#maze').append('<img class=\"flag\" src=\"./dist/assets/flags/' + color + '-flag.jpg\" alt=\"Flag\">');\r\n}\r\n\r\nfunction checkForFlag() {\r\n    // Remove any existing flag images\r\n    $('.flag').remove();\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n\r\n    if (currentRoom.flag) {\r\n        // add flag img to the room\r\n        $('#maze').append('<img class=\"flag\" src=\"./dist/assets/flags/' + currentRoom.flag + '.jpg\" alt=\"Flag\">');\r\n    }\r\n}\r\n\r\nfunction updateScore(amount) {\r\n    score += amount;\r\n\r\n    // Ensure the score doesn't go below zero\r\n    if (score < 0) {\r\n        score = 0;\r\n    }\r\n\r\n    // Update the score display\r\n    scoreTotal.text(score);\r\n}\r\n\r\nfunction toggleHelpModal() {\r\n    $('.help-modal').toggleClass('hidden');\r\n}\r\n\r\nfunction startEnemyTimer(numEnemies) {\r\n    enemyTimer = setInterval(function () {\r\n        updateScore(-100 * numEnemies);\r\n        // Stop the timer if score reaches zero\r\n        if (score <= 0) {\r\n            clearInterval(enemyTimer);\r\n            updateScore(0);\r\n        }\r\n    }, 2000);\r\n}\r\n\r\nfunction stopEnemyTimer() {\r\n    clearInterval(enemyTimer);\r\n}\r\n\r\n\r\nfunction handleEncounterInput(input) {\r\n    if (!duringEncounter) return;\r\n\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    let encounters = currentRoom.encounter;\r\n\r\n    if (!encounters) return;\r\n\r\n    encounters = Array.isArray(encounters) ? encounters : [encounters];\r\n    const currentEncounter = encounters[0];\r\n\r\n    let encounterData;\r\n    if (mazeData.enemies[currentEncounter]) {\r\n        encounterData = mazeData.enemies[currentEncounter];\r\n    } else if (mazeData.treasures[currentEncounter]) {\r\n        encounterData = mazeData.treasures[currentEncounter];\r\n    } else if (currentEncounter === \"exit\") {\r\n        encounterData = { action: 'exit', victory: `You've found the exit! Congratulations.` };\r\n    }\r\n\r\n    if (input === encounterData.action) {\r\n        encounterAnnounce(encounterData.victory);\r\n\r\n        // Stop the existing enemy timer\r\n        clearInterval(enemyTimer);\r\n\r\n        // Add 'defeated' class to the next non-defeated image\r\n        $(\"#encounter\").find(\"img:not(.defeated)\").first().addClass('defeated');\r\n\r\n        encounters.shift(); // Remove the handled encounter\r\n\r\n        const remainingEnemies = encounters.filter(e => mazeEnemies.includes(e)).length;\r\n\r\n        if (remainingEnemies > 0) {\r\n            startEnemyTimer(remainingEnemies);\r\n        }\r\n\r\n        if (mazeData.treasures[currentEncounter]) {\r\n            updateScore(mazeData.treasures[currentEncounter].value);\r\n        }\r\n\r\n        if (encounters.length === 0) {\r\n            announce(\"Room cleared! Move on to the next room.\");\r\n            currentRoom.encounter = null;\r\n            duringEncounter = false;\r\n            stopEnemyTimer();  // Stop decrementing score due to enemies\r\n            moveToCenter();\r\n            openDoors();\r\n        } else {\r\n            // Update the timer for remaining enemies\r\n            stopEnemyTimer();\r\n            startEnemyTimer(remainingEnemies); // Notice the change here\r\n            // Otherwise, proceed to the next encounter in the list\r\n            handleEncounter();\r\n        }\r\n    } else {\r\n        encounterAnnounce(\"Wrong action! Try again.\");\r\n    }\r\n}\r\n\r\n\r\nfunction movePlayer(direction) {\r\n    let newX = playerPosition.x;\r\n    let newY = playerPosition.y;\r\n\r\n    switch (direction) {\r\n        case \"north\": newY--; break;\r\n        case \"south\": newY++; break;\r\n        case \"east\": newX++; break;\r\n        case \"west\": newX--; break;\r\n    }\r\n\r\n    if (canMoveTo(newX, newY, direction)) {\r\n        leaveRoomInDirection(direction);\r\n        roomsVisited++;\r\n        roomsTraveled.text(roomsVisited);\r\n        setTimeout(function () {\r\n            playerPosition.x = newX;\r\n            playerPosition.y = newY;\r\n            enterRoomFromDirection(direction);\r\n        }, 1000);\r\n    } else {\r\n        announce(\"You can't go that way!\");\r\n    }\r\n}\r\n\r\nfunction canMoveTo(x, y, direction) {\r\n    return x >= 0 && y >= 0 && x < mazeSize && y < mazeSize && maze[playerPosition.y][playerPosition.x].doors[direction];\r\n}\r\n\r\n\r\nfunction updateMazeVisualization() {\r\n    // Clear any existing door elements from the previous room\r\n    $('.doors').remove();\r\n\r\n    // Fetch the current room based on player's position\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n\r\n    // Check for available doors and inject them into the maze\r\n    for (const direction in currentRoom.doors) {\r\n        if (currentRoom.doors[direction]) {\r\n            $(\"#maze\").append(doors[direction]);\r\n        }\r\n    }\r\n}\r\n\r\nfunction enterRoom() {\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n\r\n    // Reset encounterAnnouncer\r\n    encounterAnnounce(\"\");\r\n\r\n    if (!currentRoom.visited && currentRoom.encounter !== null) {\r\n\r\n        // Remove flag img from the room if arrived from room where you set one\r\n        $('.flag').remove();\r\n\r\n        // Mark the room as visited\r\n        currentRoom.visited = true;\r\n\r\n        // Update the maze visualization\r\n        updateMazeVisualization();\r\n\r\n        // Initiate encounter state\r\n        duringEncounter = true;\r\n\r\n        // After 1 sec close doors\r\n        setTimeout(function () {\r\n            closeDoors();\r\n        }, 1000);\r\n\r\n        handleEncounter();\r\n\r\n        // after 2 sec add class 'fight' to elements .enemy--wrapper\r\n        setTimeout(function () {\r\n            $('.enemy--wrapper').addClass('fight');\r\n        }, 2000);\r\n\r\n        // Start decrementing score for each remaining undefeated enemy\r\n        if (Array.isArray(currentRoom.encounter)) {\r\n            const numEnemies = currentRoom.encounter.filter(e => mazeEnemies.includes(e)).length;\r\n            if (numEnemies > 0) {\r\n                startEnemyTimer(numEnemies);\r\n            }\r\n        } else if (mazeEnemies.includes(currentRoom.encounter)) {\r\n            startEnemyTimer(1);\r\n        }\r\n\r\n    } else {\r\n        announce(\"Nothing in this room\");\r\n        updateMazeVisualization();\r\n        checkForFlag();\r\n    }\r\n\r\n    renderMazeInConsole();\r\n    displayEncounter(currentRoom);\r\n}\r\n\r\nfunction handleEncounter() {\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    let encounters = currentRoom.encounter;\r\n\r\n    if (!encounters) return;\r\n\r\n    encounters = Array.isArray(encounters) ? encounters : [encounters];\r\n    const currentEncounter = encounters[0];\r\n\r\n    if (mazeEnemies.includes(currentEncounter)) {\r\n        const enemyData = mazeData.enemies[currentEncounter];\r\n        announce(enemyData.announcement);\r\n    } else if (mazeTreasures.includes(currentEncounter)) {\r\n        const treasureData = mazeData.treasures[currentEncounter];\r\n        announce(treasureData.announcement);\r\n    } else if (currentEncounter === 'exit') {\r\n        announce(\"You've found the exit! Congratulations.\");\r\n        gameOver();\r\n    }\r\n}\r\n\r\nfunction gameOver() {\r\n    duringGame = false;\r\n    duringEncounter = false;\r\n\r\n    menuTrolls.show();\r\n    levelSelectWrapper.show();\r\n    menuHeader.show();\r\n\r\n    // add .game-over class to the hero element, .maze__score and .maze__rooms\r\n    $('.hero').addClass('game-over');\r\n    $('.maze__score').addClass('game-over');\r\n    $('.maze__rooms').addClass('game-over');\r\n\r\n    // delete the background images but not the .dancing-troll\r\n    $('.maze__menu-background').not('.dancing-troll').remove();\r\n\r\n    encounterAnnounce(\"Type start to play again.\");\r\n\r\n}\r\n\r\n\r\nfunction getRandomInt(max) {\r\n    return Math.floor(Math.random() * max);\r\n}\r\n\r\nfunction getDistance(pos1, pos2) {\r\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\r\n}\r\n\r\nfunction renderMazeInConsole() {\r\n    let visualization = \"\";\r\n\r\n    for (let i = 0; i < mazeSize; i++) {\r\n        for (let j = 0; j < mazeSize; j++) {\r\n            if (j == 0) {\r\n                visualization += \"|\";\r\n            }\r\n\r\n            if (playerPosition.y == i && playerPosition.x == j) {\r\n                visualization += \" X \";\r\n            } else {\r\n                visualization += \"   \";\r\n            }\r\n\r\n            visualization += \"|\";\r\n        }\r\n        visualization += \"\\n\";\r\n        visualization += Array(mazeSize * 4 + 1).join(\"_\");\r\n        visualization += \"\\n\";\r\n    }\r\n\r\n    console.log(visualization);\r\n}\r\n\r\nfunction displayEncounter(room) {\r\n    $('#encounter').empty();\r\n    if (room.encounter) {\r\n        const encounters = Array.isArray(room.encounter) ? room.encounter : [room.encounter];\r\n\r\n        encounters.forEach(item => {\r\n            let content = '';\r\n            if (mazeEnemies.includes(item)) {\r\n                content = mazeData.enemies[item].image;\r\n                content = `<div class=\"enemy--wrapper\">${content}</div>`;\r\n            } else if (mazeTreasures.includes(item)) {\r\n                content = mazeData.treasures[item].image;\r\n            } else if (item === \"exit\") {\r\n                content = '<img src=\"./dist/assets/exit.png\" alt=\"Exit\">';\r\n            }\r\n\r\n            $(\"#encounter\").append(content);\r\n        });\r\n    }\r\n}\r\n\r\n\r\nfunction getExitCoordinates(data) {\r\n    for (let i = 0; i < data.mazeSize; i++) {\r\n        for (let j = 0; j < data.mazeSize; j++) {\r\n            if (data.rooms[i][j].encounter === \"exit\") {\r\n                return { x: j, y: i };\r\n            }\r\n        }\r\n    }\r\n    return null; // This will return null if no exit is found, but in a well-designed game, there should always be an exit.\r\n}\r\n\r\nfunction announce(message) {\r\n    $('#announcer').text(message);\r\n}\r\n\r\nfunction encounterAnnounce(message) {\r\n    $('#encounterAnnouncer').text(message);\r\n}\r\n\r\nfunction closeDoors() {\r\n    $('.doors').addClass('closed');\r\n}\r\n\r\nfunction openDoors() {\r\n    $('.doors').removeClass('closed');\r\n}\r\n\r\nfunction resetGame() {\r\n    // Revert all hidden menu items\r\n    menuTrolls.show();\r\n    levelSelectWrapper.show();\r\n    menuHeader.show();\r\n\r\n    // remove .game-over class from the hero element, .maze__score and .maze__rooms\r\n    $('.hero').removeClass('game-over');\r\n    $('.maze__score').removeClass('game-over');\r\n    $('.maze__rooms').removeClass('game-over');\r\n\r\n    // delete the background images but not the .dancing-troll\r\n    $('.maze__menu-background').not('.dancing-troll').remove();\r\n\r\n    // Remove other classes from the hero element apart from .hero\r\n    $('.hero').attr('class', 'hero');\r\n\r\n    // Remove all images from the #encounter container\r\n    $('#encounter').empty();\r\n\r\n    // Unload Maze\r\n    maze = null;\r\n    mazeData = null;\r\n    playerPosition = { x: 0, y: 0 };\r\n    score = 0;\r\n    roomsVisited = 0;\r\n    scoreTotal.text(score);\r\n    roomsTraveled.text(roomsVisited);\r\n}\r\n"]}