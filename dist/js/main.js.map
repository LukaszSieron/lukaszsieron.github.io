{"version":3,"sources":["movement.js","script.js"],"names":["enterRoomFromDirection","direction","let","isEncounterInThatRoom","maze","playerPosition","y","x","encounter","animationName","$","addClass","setTimeout","removeClass","moveToCenter","enterRoom","leaveRoomInDirection","hero","fromClass","directionMap","fromNorthEncounter","fromSouthEncounter","fromEastEncounter","fromWestEncounter","hasClass","mazeData","score","roomsVisited","duringGame","duringEncounter","question","previousAnnouncement","directions","levelSelectWrapper","levelSelect","menuTrolls","menuHeader","scoreTotal","roomsTraveled","doors","north","east","south","west","loadMaze","level","val","ajax","url","type","dataType","success","data","initializeMaze","updateMazeVisualization","loadBackgroundImages","background","error","alert","backgroundSrc","loadedBackgroundImg","i","append","last","hideMenuItems","hide","mazeSize","rooms","mazeEnemies","Object","keys","enemies","mazeTreasures","treasures","exit","getExitCoordinates","j","visited","getRandomInt","getDistance","handleUserInput","input","text","announce","resetGame","encounterAnnounce","includes","movePlayer","handleEncounterInput","currentRoom","encounters","currentEncounter","Array","isArray","encounterData","action","victory","find","first","shift","value","length","openDoors","handleEncounter","newX","newY","canMoveTo","remove","renderMazeInConsole","displayEncounter","announcement","max","Math","floor","random","pos1","pos2","abs","visualization","join","console","log","room","empty","forEach","item","image","message","closeDoors","show","not","attr","keypress","e","which","this","toLowerCase"],"mappings":"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","file":"main.js","sourcesContent":["\nfunction enterRoomFromDirection(direction) {\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\n    let isEncounterInThatRoom = currentRoom.encounter !== null;\n    let animationName = '';\n\n    switch (direction) {\n        case \"north\":\n            animationName = isEncounterInThatRoom ? 'fromSouthEncounter' : 'arriveFromSouth';\n            break;\n        case \"south\":\n            animationName = isEncounterInThatRoom ? 'fromNorthEncounter' : 'arriveFromNorth';\n            break;\n        case \"east\":\n            animationName = isEncounterInThatRoom ? 'fromWestEncounter' : 'arriveFromWest';\n            break;\n        case \"west\":\n            animationName = isEncounterInThatRoom ? 'fromEastEncounter' : 'arriveFromEast';\n            break;\n    }\n\n    $('.hero').addClass(animationName);\n    // Wait for the animation to finish\n    setTimeout(function () {\n        // if it's an encounter, dont remove the animation class\n        if (!isEncounterInThatRoom) {\n            $('.hero').removeClass(animationName);\n            moveToCenter();\n        }\n    }, 1000);\n    enterRoom();\n}\n\nfunction leaveRoomInDirection(direction) {\n    let animationName = '';\n    switch (direction) {\n        case \"north\":\n            animationName = 'leaveToNorth';\n            break;\n        case \"south\":\n            animationName = 'leaveToSouth';\n            break;\n        case \"east\":\n            animationName = 'leaveToEast';\n            break;\n        case \"west\":\n            animationName = 'leaveToWest';\n            break;\n    }\n    $('.hero').addClass(animationName);\n    // Wait for the animation to finish\n    setTimeout(function () {\n        $('.hero').removeClass(animationName);\n    }, 1000);\n\n}\n\nfunction moveToCenter() {\n    const hero = $('.hero');\n    const directionMap = {\n        'fromNorthEncounter': 'toCenterFromNorth',\n        'fromSouthEncounter': 'toCenterFromSouth',\n        'fromEastEncounter': 'toCenterFromEast',\n        'fromWestEncounter': 'toCenterFromWest',\n    };\n\n    for (let fromClass in directionMap) {\n        if (hero.hasClass(fromClass)) {\n            hero.addClass(directionMap[fromClass])\n                .removeClass(fromClass);\n            break;\n        }\n    }\n\n    // now after animation finishes after 1 sec remove the toCenter class\n    setTimeout(function () {\n        hero.removeClass('toCenterFromNorth toCenterFromSouth toCenterFromEast toCenterFromWest');\n    }, 1000);\n}","let mazeData = null;\r\n\r\n// Global variables\r\nlet playerPosition = { x: 0, y: 0 };\r\nlet score = 0;\r\nlet roomsVisited = 0;\r\nlet duringGame = false;\r\nlet duringEncounter = false;\r\nlet question = false;\r\n\r\n// Needed to store the previous announcement when the player is asked a question\r\nlet previousAnnouncement = null;\r\n\r\nconst directions = [\"north\", \"south\", \"east\", \"west\"];\r\n\r\n// html elements\r\nlet levelSelectWrapper = $('.maze__level-select');\r\nlet levelSelect = $('#level');\r\nlet menuTrolls = $('.dancing-troll');\r\nlet menuHeader = $('.menu__heading');\r\nlet scoreTotal = $('#score');\r\nlet roomsTraveled = $('#rooms');\r\n\r\nconst doors = {\r\n    north: '<span class=\"doors doors--north\"></span>',\r\n    east: '<span class=\"doors doors--east\"></span>',\r\n    south: '<span class=\"doors doors--south\"></span>',\r\n    west: '<span class=\"doors doors--west\"></span>'\r\n}\r\n\r\n// User input handling\r\n$(\"#userInput\").keypress(function (e) {\r\n    if (e.which === 13) { // Enter key pressed\r\n        let input = $(this).val().toLowerCase();\r\n        handleUserInput(input);\r\n        // clear the input field\r\n        $(this).val(\"\");\r\n    }\r\n});\r\n\r\nfunction loadMaze() {\r\n    let level = levelSelect.val();\r\n\r\n    $.ajax({\r\n        url: './maze-configs/' + level + '.json',\r\n        type: 'GET',\r\n        dataType: 'json',\r\n        success: function (data) {\r\n            mazeData = data;\r\n            initializeMaze(data);\r\n            updateMazeVisualization();\r\n\r\n            // Load the background images\r\n            loadBackgroundImages(data.background);\r\n        },\r\n        error: function () {\r\n            alert('Failed to load maze.');\r\n        }\r\n    });\r\n}\r\n\r\nfunction loadBackgroundImages(backgroundSrc) {\r\n    // Load the background images\r\n    let loadedBackgroundImg = '<img class=\"maze__menu-background\" src=\"' + backgroundSrc + '\" alt=\"Background\">';\r\n\r\n    // create 4 copies of the background image, add class maze__menu-background-- + number to each and append to #maze\r\n    for (let i = 1; i < 5; i++) {\r\n        $('#maze').append(loadedBackgroundImg);\r\n        $('.maze__menu-background').last().addClass('maze__menu-background--' + i);\r\n    }\r\n}\r\n\r\nfunction hideMenuItems() {\r\n    menuTrolls.hide();\r\n    levelSelectWrapper.hide();\r\n    menuHeader.hide();\r\n}\r\n\r\nfunction initializeMaze(data) {\r\n    mazeSize = data.mazeSize;\r\n    maze = data.rooms;\r\n    mazeEnemies = Object.keys(data.enemies);  // get enemy keys\r\n    mazeTreasures = Object.keys(data.treasures);  // get treasure keys\r\n    exit = getExitCoordinates(data);\r\n\r\n    for (let i = 0; i < mazeSize; i++) {\r\n        for (let j = 0; j < mazeSize; j++) {\r\n            maze[i][j].visited = false;\r\n        }\r\n    }\r\n\r\n    do {\r\n        playerPosition.x = getRandomInt(mazeSize);\r\n        playerPosition.y = getRandomInt(mazeSize);\r\n    } while (getDistance(playerPosition, exit) < 3);\r\n}\r\n\r\nfunction handleUserInput(input) {\r\n\r\n    if (input === \"start\" && !duringGame) {\r\n        duringGame = true;\r\n        hideMenuItems();\r\n        loadMaze();\r\n        announce(\"You are in a maze. Try to find the exit. Type 'help' for more instructions.\");\r\n    } else if (input === \"start\" && duringGame) {\r\n        previousAnnouncement = $('#announcer').text();\r\n        announce(\"Do you want to return to the main menu? Type 'yes' or 'no'.\");\r\n        question = true;\r\n    } else if (question) {\r\n        if (input === \"yes\") {\r\n            // Reset everything\r\n            duringGame = false;\r\n            duringEncounter = false;\r\n            question = false;\r\n            resetGame();\r\n            announce(\"Game has been reset. Type 'start' to begin again.\");\r\n        } else if (input === \"no\") {\r\n            // Continue game\r\n            question = false;\r\n            announce(previousAnnouncement);\r\n        } else {\r\n            encounterAnnounce(\"Please answer with 'yes' or 'no'.\");\r\n        }\r\n    } else if (directions.includes(input)) {\r\n        // Check if the player is during an encounter. If so, notify them and prevent movement.\r\n        if (duringEncounter) {\r\n            encounterAnnounce(\"You can't leave until you've dealt with the encounter!\");\r\n        } else {\r\n            movePlayer(input);\r\n        }\r\n    } else if (duringEncounter) {\r\n        // Handle the encounter input\r\n        handleEncounterInput(input);\r\n    } else {\r\n        announce(\"Unknown command. Type 'help' for more instructions.\");\r\n    }\r\n}\r\n\r\nfunction handleEncounterInput(input) {\r\n    if (!duringEncounter) return;\r\n\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    let encounters = currentRoom.encounter;\r\n\r\n    if (!encounters) {\r\n        return;\r\n    }\r\n\r\n    encounters = Array.isArray(encounters) ? encounters : [encounters];\r\n    const currentEncounter = encounters[0];\r\n\r\n    let encounterData;\r\n    if (mazeData.enemies[currentEncounter]) {\r\n        encounterData = mazeData.enemies[currentEncounter];\r\n    } else if (mazeData.treasures[currentEncounter]) {\r\n        encounterData = mazeData.treasures[currentEncounter];\r\n    } else if (currentEncounter === \"exit\") {\r\n        encounterData = { action: 'exit', victory: `You've found the exit! Congratulations.` };\r\n    }\r\n\r\n    if (input === encounterData.action) {\r\n        encounterAnnounce(encounterData.victory);\r\n\r\n        // Add 'defeated' class to the next non-defeated image\r\n        $(\"#encounter\").find(\"img:not(.defeated)\").first().addClass('defeated');\r\n\r\n        encounters.shift(); // Remove the handled encounter\r\n\r\n        if (mazeData.treasures[currentEncounter]) {\r\n            score += mazeData.treasures[currentEncounter].value; // Increment score for treasures\r\n            scoreTotal.text(score);\r\n        }\r\n\r\n        if (encounters.length === 0) {\r\n            announce(\"Room cleared! Move on to the next room.\");\r\n            currentRoom.encounter = null;\r\n            duringEncounter = false;\r\n            moveToCenter();\r\n            openDoors();\r\n        } else {\r\n            // Otherwise, proceed to the next encounter in the list\r\n            handleEncounter();\r\n        }\r\n    } else {\r\n        encounterAnnounce(\"Wrong action! Try again.\");\r\n    }\r\n}\r\n\r\nfunction movePlayer(direction) {\r\n    let newX = playerPosition.x;\r\n    let newY = playerPosition.y;\r\n\r\n    switch (direction) {\r\n        case \"north\": newY--; break;\r\n        case \"south\": newY++; break;\r\n        case \"east\": newX++; break;\r\n        case \"west\": newX--; break;\r\n    }\r\n\r\n    if (canMoveTo(newX, newY, direction)) {\r\n        leaveRoomInDirection(direction);\r\n        roomsVisited++;\r\n        roomsTraveled.text(roomsVisited);\r\n        setTimeout(function () {\r\n            playerPosition.x = newX;\r\n            playerPosition.y = newY;\r\n            enterRoomFromDirection(direction);\r\n        }, 1000);\r\n    } else {\r\n        announce(\"You can't go that way!\");\r\n    }\r\n}\r\n\r\nfunction canMoveTo(x, y, direction) {\r\n    return x >= 0 && y >= 0 && x < mazeSize && y < mazeSize && maze[playerPosition.y][playerPosition.x].doors[direction];\r\n}\r\n\r\n\r\nfunction updateMazeVisualization() {\r\n    // Clear any existing door elements from the previous room\r\n    $('.doors').remove();\r\n\r\n    // Fetch the current room based on player's position\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n\r\n    // Check for available doors and inject them into the maze\r\n    for (const direction in currentRoom.doors) {\r\n        if (currentRoom.doors[direction]) {\r\n            $(\"#maze\").append(doors[direction]);\r\n        }\r\n    }\r\n}\r\n\r\nfunction enterRoom() {\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    // reset encounterAnnouncer\r\n    encounterAnnounce(\"\");\r\n\r\n    if (!currentRoom.visited && currentRoom.encounter !== null) {\r\n        currentRoom.visited = true;\r\n        updateMazeVisualization();\r\n\r\n        if (currentRoom.encounter === \"exit\") {\r\n            announce(\"Congratulations! You found the exit!\");\r\n            // End game or progress to next level\r\n        } else {\r\n            duringEncounter = true;\r\n            handleEncounter();\r\n        }\r\n    } else {\r\n        announce(\"Nothing in this room\");\r\n        updateMazeVisualization();\r\n    }\r\n\r\n    renderMazeInConsole();\r\n    displayEncounter(currentRoom);\r\n}\r\n\r\nfunction handleEncounter() {\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    let encounters = currentRoom.encounter;\r\n\r\n    if (!encounters) return;\r\n\r\n    encounters = Array.isArray(encounters) ? encounters : [encounters];\r\n    const currentEncounter = encounters[0];\r\n\r\n    if (mazeEnemies.includes(currentEncounter)) {\r\n        const enemyData = mazeData.enemies[currentEncounter];\r\n        announce(enemyData.announcement);\r\n    } else if (mazeTreasures.includes(currentEncounter)) {\r\n        const treasureData = mazeData.treasures[currentEncounter];\r\n        announce(treasureData.announcement);\r\n    } else if (currentEncounter === 'exit') {\r\n        announce(\"You've found the exit!!!!!!!! Congratulations.\");\r\n    }\r\n}\r\n\r\nfunction getRandomInt(max) {\r\n    return Math.floor(Math.random() * max);\r\n}\r\n\r\nfunction getDistance(pos1, pos2) {\r\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\r\n}\r\n\r\nfunction renderMazeInConsole() {\r\n    let visualization = \"\";\r\n\r\n    for (let i = 0; i < mazeSize; i++) {\r\n        for (let j = 0; j < mazeSize; j++) {\r\n            if (j == 0) {\r\n                visualization += \"|\";\r\n            }\r\n\r\n            if (playerPosition.y == i && playerPosition.x == j) {\r\n                visualization += \" X \";\r\n            } else {\r\n                visualization += \"   \";\r\n            }\r\n\r\n            visualization += \"|\";\r\n        }\r\n        visualization += \"\\n\";\r\n        visualization += Array(mazeSize * 4 + 1).join(\"_\");\r\n        visualization += \"\\n\";\r\n    }\r\n\r\n    console.log(visualization);\r\n}\r\n\r\nfunction displayEncounter(room) {\r\n    $('#encounter').empty();\r\n    if (room.encounter) {\r\n        const encounters = Array.isArray(room.encounter) ? room.encounter : [room.encounter];\r\n\r\n        encounters.forEach(item => {\r\n            if (mazeEnemies.includes(item)) {\r\n                $(\"#encounter\").append(mazeData.enemies[item].image);\r\n            } else if (mazeTreasures.includes(item)) {\r\n                $(\"#encounter\").append(mazeData.treasures[item].image);\r\n            } else if (item === \"exit\") {\r\n                $(\"#encounter\").append('<img src=\"./dist/assets/exit.png\" alt=\"Exit\">');\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n\r\nfunction getExitCoordinates(data) {\r\n    for (let i = 0; i < data.mazeSize; i++) {\r\n        for (let j = 0; j < data.mazeSize; j++) {\r\n            if (data.rooms[i][j].encounter === \"exit\") {\r\n                return { x: j, y: i };\r\n            }\r\n        }\r\n    }\r\n    return null; // This will return null if no exit is found, but in a well-designed game, there should always be an exit.\r\n}\r\n\r\nfunction announce(message) {\r\n    $('#announcer').text(message);\r\n}\r\n\r\nfunction encounterAnnounce(message) {\r\n    $('#encounterAnnouncer').text(message);\r\n}\r\n\r\nfunction closeDoors() {\r\n    $('.doors').addClass('closed');\r\n}\r\n\r\nfunction openDoors() {\r\n    $('.doors').removeClass('closed');\r\n}\r\n\r\nfunction resetGame() {\r\n    // Revert all hidden menu items\r\n    menuTrolls.show();\r\n    levelSelectWrapper.show();\r\n    menuHeader.show();\r\n\r\n    // delete the background images but not the .dancing-troll\r\n    $('.maze__menu-background').not('.dancing-troll').remove();\r\n\r\n    // Remove other classes from the hero element apart from .hero\r\n    $('.hero').attr('class', 'hero');\r\n\r\n    // Remove all images from the #encounter container\r\n    $('#encounter').empty();\r\n\r\n    // Unload Maze\r\n    maze = null;\r\n    mazeData = null;\r\n    playerPosition = { x: 0, y: 0 };\r\n    score = 0;\r\n    roomsVisited = 0;\r\n    scoreTotal.text(score);\r\n    roomsTraveled.text(roomsVisited);\r\n}"]}