{"version":3,"sources":["movement.js","script.js","tests.js","utilities.js"],"names":["movePlayer","direction","let","newX","playerPosition","x","newY","y","duringGame","canMoveTo","leaveRoomInDirection","roomsVisited","roomsTraveled","text","setTimeout","enterRoomFromDirection","announce","mazeSize","maze","doors","isEncounterInThatRoom","encounter","animationName","$","addClass","removeClass","moveToCenter","enterRoom","hero","fromClass","directionMap","fromNorthEncounter","fromSouthEncounter","fromEastEncounter","fromWestEncounter","hasClass","mazeData","score","duringEncounter","question","flagQuestion","enemyTimer","previousAnnouncement","directions","levelSelectWrapper","levelSelect","menuTrolls","menuHeader","scoreTotal","north","east","south","west","async","loadMaze","level","val","data","await","fetch","json","validationResult","validateMaze","isValid","initializeMaze","updateMazeVisualization","loadBackgroundImages","background","alert","message","error","backgroundSrc","i","append","rooms","mazeEnemies","Object","keys","enemies","mazeTreasures","treasures","exit","getExitCoordinates","setInitialPlayerPosition","clearInitialRoom","getRandomInt","getDistance","visited","handleUserInput","input","handleEncounterState","handleQuestionState","handleFlagQuestionState","handleGameState","handleMenuState","resetGame","hideMenuItems","toggleHelpModal","includes","handleEncounterInput","encounterAnnounce","insertFlag","color","setFlagInCurrentRoom","updateScore","displayFlag","flag","checkForFlag","remove","currentRoom","toggleClass","startEnemyTimer","numEnemies","setInterval","stopEnemyTimer","clearInterval","encounters","currentEncounter","Array","isArray","encounterData","action","victory","find","first","shift","remainingEnemies","filter","e","length","value","openDoors","handleEncounter","getEncounters","room","getCurrentRoom","announcement","gameOver","currentDoors","$maze","displayEncounter","empty","forEach","item","content","image","resetEncounterAnnouncer","handleRepeatedEntry","handleFirstTimeEntry","renderMazeInConsole","closeDoors","toggleGameOverClasses","add","cls","showMenuItems","show","removeBackgroundImages","not","attr","result","hasSingleExit","validateDoorIntegrity","isMazeSolvable","exitCount","exitLocations","row","j","push","console","log","join","rows","cols","exitLocation","col","from","fill","dfs","max","Math","floor","random","pos1","pos2","abs","hide","amount","visualization","on","keypress","which","this","toLowerCase"],"mappings":"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","file":"main.js","sourcesContent":["function movePlayer(direction) {\n    let newX = playerPosition.x;\n    let newY = playerPosition.y;\n\n    if (!duringGame) {\n        announce(\"You must start the game first!\");\n        return;\n    }\n\n    switch (direction) {\n        case \"north\": newY--; break;\n        case \"south\": newY++; break;\n        case \"east\": newX++; break;\n        case \"west\": newX--; break;\n    }\n\n    if (canMoveTo(newX, newY, direction)) {\n        leaveRoomInDirection(direction);\n        roomsVisited++;\n        roomsTraveled.text(roomsVisited);\n        setTimeout(function () {\n            playerPosition.x = newX;\n            playerPosition.y = newY;\n            enterRoomFromDirection(direction);\n        }, 1000);\n    } else {\n        announce(\"You can't go that way!\");\n    }\n}\n\nfunction canMoveTo(x, y, direction) {\n    return x >= 0 && y >= 0 && x < mazeSize && y < mazeSize && maze[playerPosition.y][playerPosition.x].doors[direction];\n}\n\nfunction enterRoomFromDirection(direction) {\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\n    let isEncounterInThatRoom = currentRoom.encounter !== null;\n    let animationName = '';\n\n    switch (direction) {\n        case \"north\":\n            animationName = isEncounterInThatRoom ? 'fromSouthEncounter' : 'arriveFromSouth';\n            break;\n        case \"south\":\n            animationName = isEncounterInThatRoom ? 'fromNorthEncounter' : 'arriveFromNorth';\n            break;\n        case \"east\":\n            animationName = isEncounterInThatRoom ? 'fromWestEncounter' : 'arriveFromWest';\n            break;\n        case \"west\":\n            animationName = isEncounterInThatRoom ? 'fromEastEncounter' : 'arriveFromEast';\n            break;\n    }\n\n    $('.hero').addClass(animationName);\n    // Wait for the animation to finish\n    setTimeout(function () {\n        // if it's an encounter, dont remove the animation class\n        if (!isEncounterInThatRoom) {\n            $('.hero').removeClass(animationName);\n            moveToCenter();\n        }\n    }, 1000);\n    enterRoom();\n}\n\nfunction leaveRoomInDirection(direction) {\n    let animationName = '';\n    switch (direction) {\n        case \"north\":\n            animationName = 'leaveToNorth';\n            break;\n        case \"south\":\n            animationName = 'leaveToSouth';\n            break;\n        case \"east\":\n            animationName = 'leaveToEast';\n            break;\n        case \"west\":\n            animationName = 'leaveToWest';\n            break;\n    }\n    $('.hero').addClass(animationName);\n    // Wait for the animation to finish\n    setTimeout(function () {\n        $('.hero').removeClass(animationName);\n    }, 1000);\n\n}\n\nfunction moveToCenter() {\n    const hero = $('.hero');\n    const directionMap = {\n        'fromNorthEncounter': 'toCenterFromNorth',\n        'fromSouthEncounter': 'toCenterFromSouth',\n        'fromEastEncounter': 'toCenterFromEast',\n        'fromWestEncounter': 'toCenterFromWest',\n    };\n\n    for (let fromClass in directionMap) {\n        if (hero.hasClass(fromClass)) {\n            hero.addClass(directionMap[fromClass])\n                .removeClass(fromClass);\n            break;\n        }\n    }\n\n    // now after animation finishes after 1 sec remove the toCenter class\n    setTimeout(function () {\n        hero.removeClass('toCenterFromNorth toCenterFromSouth toCenterFromEast toCenterFromWest');\n    }, 1000);\n}","let mazeData = null;\r\n\r\n// Global variables\r\nlet playerPosition = { x: 0, y: 0 };\r\nlet score = 0;\r\nlet roomsVisited = 0;\r\nlet duringGame = false;\r\nlet duringEncounter = false;\r\nlet question = false;\r\nlet flagQuestion = false;\r\nlet enemyTimer; // to hold the interval for decrementing score due to enemies\r\n\r\n// Needed to store the previous announcement when the player is asked a question\r\nlet previousAnnouncement = null;\r\n\r\nconst directions = [\"north\", \"south\", \"east\", \"west\"];\r\n\r\n// html elements\r\nlet levelSelectWrapper = $('.maze__level-select');\r\nlet levelSelect = $('#level');\r\nlet menuTrolls = $('.dancing-troll');\r\nlet menuHeader = $('.menu__heading');\r\nlet scoreTotal = $('#score');\r\nlet roomsTraveled = $('#rooms');\r\n\r\nconst doors = {\r\n    north: '<span class=\"doors doors--north\"></span>',\r\n    east: '<span class=\"doors doors--east\"></span>',\r\n    south: '<span class=\"doors doors--south\"></span>',\r\n    west: '<span class=\"doors doors--west\"></span>'\r\n}\r\n\r\n// toggle help modal on click\r\n$('#closeModal').on('click', toggleHelpModal);\r\n\r\n// User input handling\r\n$(\"#userInput\").keypress(function (e) {\r\n    if (e.which === 13) { // Enter key pressed\r\n        let input = $(this).val().toLowerCase();\r\n        handleUserInput(input);\r\n        // clear the input field\r\n        $(this).val(\"\");\r\n    }\r\n});\r\n\r\nasync function loadMaze() {\r\n    const level = levelSelect.val();\r\n    try {\r\n        const response = await fetch(`./maze-configs/${level}.json`);\r\n        const data = await response.json();\r\n        const validationResult = validateMaze(data);\r\n        if (validationResult.isValid) {\r\n            mazeData = data;\r\n            initializeMaze(data);\r\n            updateMazeVisualization();\r\n            loadBackgroundImages(data.background);\r\n        } else {\r\n            alert(`Invalid maze configuration: ${validationResult.message}`);\r\n        }\r\n    } catch (error) {\r\n        alert('Failed to load maze.');\r\n    }\r\n}\r\n\r\nfunction loadBackgroundImages(backgroundSrc) {\r\n    for (let i = 1; i <= 4; i++) {\r\n        $('#maze').append(`<img class=\"maze__menu-background maze__menu-background--${i}\" src=\"${backgroundSrc}\" alt=\"Background\">`);\r\n    }\r\n}\r\n\r\nfunction initializeMaze(data) {\r\n    mazeSize = data.mazeSize;\r\n    maze = data.rooms;\r\n    mazeEnemies = Object.keys(data.enemies);\r\n    mazeTreasures = Object.keys(data.treasures);\r\n    exit = getExitCoordinates(data);\r\n    setInitialPlayerPosition();\r\n    clearInitialRoom();\r\n}\r\n\r\nfunction setInitialPlayerPosition() {\r\n    do {\r\n        playerPosition.x = getRandomInt(mazeSize);\r\n        playerPosition.y = getRandomInt(mazeSize);\r\n    } while (getDistance(playerPosition, exit) < 3);\r\n}\r\n\r\nfunction clearInitialRoom() {\r\n    maze[playerPosition.y][playerPosition.x].encounter = null;\r\n    maze[playerPosition.y][playerPosition.x].visited = true;\r\n}\r\n\r\nfunction handleUserInput(input) {\r\n    if (!duringGame) {\r\n        handleMenuState(input);\r\n    } else if (duringGame && !duringEncounter && !question && !flagQuestion) {\r\n        handleGameState(input);\r\n    } else if (duringEncounter) {\r\n        handleEncounterState(input);\r\n    } else if (question) {\r\n        handleQuestionState(input);\r\n    } else if (flagQuestion) {\r\n        handleFlagQuestionState(input);\r\n    } else {\r\n        announce(\"Unknown command. Type 'help' for more instructions.\");\r\n    }\r\n}\r\n\r\nfunction handleMenuState(input) {\r\n    if (input === \"start\") {\r\n        duringGame = true;\r\n        resetGame();\r\n        hideMenuItems();\r\n        loadMaze();\r\n        announce(\"You are in a maze. Try to find the exit. Type 'help' for more instructions.\");\r\n    } else if (input === \"help\") {\r\n        toggleHelpModal();\r\n    } else {\r\n        announce(\"Unknown command. Type 'help' for more instructions.\");\r\n    }\r\n}\r\n\r\nfunction handleGameState(input) {\r\n    if (input === \"start\") {\r\n        previousAnnouncement = $('#announcer').text();\r\n        announce(\"Do you want to return to the main menu? Type 'yes' or 'no'.\");\r\n        question = true;\r\n    } else if (input === 'flag') {\r\n        previousAnnouncement = $('#announcer').text();\r\n        announce(\"Insert flag for 100 points. Pick color, type 'red', 'green', 'yellow' or 'cancel' to cancel.\");\r\n        flagQuestion = true;\r\n    } else if (directions.includes(input)) {\r\n        movePlayer(input);\r\n    } else {\r\n        announce(\"Unknown command. Type 'help' for more instructions.\");\r\n    }\r\n}\r\n\r\nfunction handleEncounterState(input) {\r\n    handleEncounterInput(input);\r\n}\r\n\r\nfunction handleQuestionState(input) {\r\n    if (input === \"yes\") {\r\n        duringGame = false;\r\n        duringEncounter = false;\r\n        question = false;\r\n        resetGame();\r\n        announce(\"Game has been reset. Type 'start' to begin again.\");\r\n    } else if (input === \"no\") {\r\n        question = false;\r\n        announce(previousAnnouncement);\r\n    } else {\r\n        encounterAnnounce(\"Please answer with 'yes' or 'no'.\");\r\n    }\r\n}\r\n\r\nfunction handleFlagQuestionState(input) {\r\n    if (input === 'red' || input === 'green' || input === 'yellow') {\r\n        insertFlag(input);\r\n    } else if (input === 'cancel') {\r\n        flagQuestion = false;\r\n        announce(previousAnnouncement);\r\n    } else {\r\n        announce(\"Unknown flag color. Type 'red', 'green', 'yellow' or 'cancel' to cancel.\");\r\n    }\r\n}\r\n\r\nfunction insertFlag(color) {\r\n    setFlagInCurrentRoom(color);\r\n    updateScore(-100);\r\n    displayFlag(color);\r\n    flagQuestion = false;\r\n    encounterAnnounce(`${color} flag set in this room!`);\r\n    announce(previousAnnouncement);\r\n}\r\n\r\nfunction setFlagInCurrentRoom(color) {\r\n    maze[playerPosition.y][playerPosition.x].flag = `${color}-flag`;\r\n}\r\n\r\nfunction displayFlag(color) {\r\n    $('#maze').append(`<img class=\"flag\" src=\"./dist/assets/flags/${color}-flag.jpg\" alt=\"Flag\">`);\r\n}\r\n\r\nfunction checkForFlag() {\r\n    $('.flag').remove();\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    if (currentRoom.flag) {\r\n        $('#maze').append(`<img class=\"flag\" src=\"./dist/assets/flags/${currentRoom.flag}.jpg\" alt=\"Flag\">`);\r\n    }\r\n}\r\n\r\nfunction toggleHelpModal() {\r\n    $('.help-modal').toggleClass('hidden');\r\n}\r\n\r\nfunction startEnemyTimer(numEnemies) {\r\n    const decrementScore = () => {\r\n        updateScore(-100 * numEnemies);\r\n        if (score <= 0) {\r\n            stopEnemyTimer();\r\n            updateScore(0);\r\n        }\r\n    };\r\n    enemyTimer = setInterval(decrementScore, 2000);\r\n}\r\n\r\nfunction stopEnemyTimer() {\r\n    clearInterval(enemyTimer);\r\n}\r\n\r\nfunction handleEncounterInput(input) {\r\n    if (!duringEncounter) return;\r\n\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    let encounters = currentRoom.encounter;\r\n\r\n    if (!encounters) return;\r\n\r\n    encounters = Array.isArray(encounters) ? encounters : [encounters];\r\n    const currentEncounter = encounters[0];\r\n\r\n    let encounterData;\r\n    if (mazeData.enemies[currentEncounter]) {\r\n        encounterData = mazeData.enemies[currentEncounter];\r\n    } else if (mazeData.treasures[currentEncounter]) {\r\n        encounterData = mazeData.treasures[currentEncounter];\r\n    } else if (currentEncounter === \"exit\") {\r\n        encounterData = { action: 'exit', victory: `You've found the exit! Congratulations.` };\r\n    }\r\n\r\n    if (input === encounterData.action) {\r\n        encounterAnnounce(encounterData.victory);\r\n\r\n        // Stop the existing enemy timer\r\n        clearInterval(enemyTimer);\r\n\r\n        // Add 'defeated' class to the next non-defeated image\r\n        $(\"#encounter\").find(\"img:not(.defeated)\").first().addClass('defeated');\r\n\r\n        encounters.shift(); // Remove the handled encounter\r\n\r\n        const remainingEnemies = encounters.filter(e => mazeEnemies.includes(e)).length;\r\n\r\n        if (remainingEnemies > 0) {\r\n            startEnemyTimer(remainingEnemies);\r\n        }\r\n\r\n        if (mazeData.treasures[currentEncounter]) {\r\n            updateScore(mazeData.treasures[currentEncounter].value);\r\n        }\r\n\r\n        if (encounters.length === 0) {\r\n            announce(\"Room cleared! Move on to the next room.\");\r\n            currentRoom.encounter = null;\r\n            duringEncounter = false;\r\n            stopEnemyTimer();  // Stop decrementing score due to enemies\r\n            moveToCenter();\r\n            openDoors();\r\n        } else {\r\n            // Update the timer for remaining enemies\r\n            stopEnemyTimer();\r\n            startEnemyTimer(remainingEnemies);\r\n            // Otherwise, proceed to the next encounter in the list\r\n            handleEncounter();\r\n        }\r\n    } else {\r\n        encounterAnnounce(\"Wrong action! Try again.\");\r\n    }\r\n}\r\n\r\nfunction getEncounters(room) {\r\n    return Array.isArray(room.encounter) ? room.encounter : [room.encounter];\r\n}\r\n\r\nfunction getCurrentRoom() {\r\n    return maze[playerPosition.y][playerPosition.x];\r\n}\r\n\r\nfunction handleEncounter() {\r\n    const currentRoom = getCurrentRoom();\r\n    const encounters = getEncounters(currentRoom);\r\n    const currentEncounter = encounters[0];\r\n\r\n    let announcement = '';\r\n\r\n    if (mazeEnemies.includes(currentEncounter)) {\r\n        announcement = mazeData.enemies[currentEncounter].announcement;\r\n    } else if (mazeTreasures.includes(currentEncounter)) {\r\n        announcement = mazeData.treasures[currentEncounter].announcement;\r\n    } else if (currentEncounter === 'exit') {\r\n        announcement = \"You've found the exit! Congratulations.\";\r\n        gameOver();\r\n    }\r\n\r\n    if (announcement) {\r\n        announce(announcement);\r\n    }\r\n}\r\n\r\nfunction updateMazeVisualization() {\r\n    // Clear any existing door elements from the previous room\r\n    $('.doors').remove();\r\n\r\n    // Fetch the current room based on player's position\r\n    const { doors: currentDoors } = maze[playerPosition.y][playerPosition.x];\r\n\r\n    // Check for available doors and inject them into the maze\r\n    const $maze = $(\"#maze\");\r\n    for (const direction in currentDoors) {\r\n        if (currentDoors[direction]) {\r\n            $maze.append(doors[direction]);\r\n        }\r\n    }\r\n}\r\n\r\nfunction displayEncounter(room) {\r\n    $('#encounter').empty();\r\n    if (room.encounter) {\r\n        const encounters = Array.isArray(room.encounter) ? room.encounter : [room.encounter];\r\n\r\n        encounters.forEach(item => {\r\n            let content = '';\r\n            if (mazeEnemies.includes(item)) {\r\n                content = mazeData.enemies[item].image;\r\n                content = `<div class=\"enemy--wrapper\">${content}</div>`;\r\n            } else if (mazeTreasures.includes(item)) {\r\n                content = mazeData.treasures[item].image;\r\n            } else if (item === \"exit\") {\r\n                content = '<img src=\"./dist/assets/exit.png\" alt=\"Exit\">';\r\n            }\r\n\r\n            $(\"#encounter\").append(content);\r\n        });\r\n    }\r\n}\r\n\r\nfunction enterRoom() {\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    resetEncounterAnnouncer();\r\n\r\n    if (!currentRoom.visited && currentRoom.encounter !== null) {\r\n        handleFirstTimeEntry(currentRoom);\r\n    } else {\r\n        handleRepeatedEntry(currentRoom);\r\n    }\r\n\r\n    renderMazeInConsole();\r\n    displayEncounter(currentRoom);\r\n}\r\n\r\nfunction resetEncounterAnnouncer() {\r\n    encounterAnnounce(\"\");\r\n}\r\n\r\nfunction handleFirstTimeEntry(currentRoom) {\r\n    $('.flag').remove();  // Remove flag img from the room if arrived from room where you set one\r\n    currentRoom.visited = true;  // Mark the room as visited\r\n    updateMazeVisualization();  // Update the maze visualization\r\n    duringEncounter = true;  // Initiate encounter state\r\n\r\n    setTimeout(() => closeDoors(), 1000);  // After 1 sec close doors\r\n    handleEncounter();  // Handle the encounter\r\n\r\n    setTimeout(() => $('.enemy--wrapper').addClass('fight'), 2000);  // After 2 sec add class 'fight' to elements .enemy--wrapper\r\n\r\n    const numEnemies = Array.isArray(currentRoom.encounter)\r\n        ? currentRoom.encounter.filter(e => mazeEnemies.includes(e)).length\r\n        : mazeEnemies.includes(currentRoom.encounter) ? 1 : 0;\r\n\r\n    if (numEnemies > 0) startEnemyTimer(numEnemies);\r\n}\r\n\r\nfunction handleRepeatedEntry(currentRoom) {\r\n    announce(\"Nothing in this room\");\r\n    updateMazeVisualization();\r\n    checkForFlag();\r\n}\r\n\r\nfunction toggleGameOverClasses(add) {\r\n    const classes = ['hero', 'maze__score', 'maze__rooms'];\r\n    classes.forEach(cls => $(`.${cls}`).toggleClass('game-over', add));\r\n}\r\n\r\nfunction showMenuItems() {\r\n    menuTrolls.show();\r\n    levelSelectWrapper.show();\r\n    menuHeader.show();\r\n}\r\n\r\nfunction removeBackgroundImages() {\r\n    $('.maze__menu-background').not('.dancing-troll').remove();\r\n}\r\n\r\nfunction gameOver() {\r\n    duringGame = false;\r\n    duringEncounter = false;\r\n\r\n    showMenuItems();\r\n    toggleGameOverClasses(true);\r\n    removeBackgroundImages();\r\n\r\n    encounterAnnounce(\"Type start to play again.\");\r\n}\r\n\r\nfunction resetGame() {\r\n    showMenuItems();\r\n    $('.doors').remove();  // Remove all .doors elements\r\n    toggleGameOverClasses(false);\r\n    removeBackgroundImages();\r\n\r\n    // Remove other classes from the hero element apart from .hero\r\n    $('.hero').attr('class', 'hero');\r\n\r\n    // Remove all images from the #encounter container\r\n    $('#encounter').empty();\r\n\r\n    //cler encounter announcer\r\n    resetEncounterAnnouncer();\r\n\r\n    // Unload Maze\r\n    maze = null;\r\n    mazeData = null;\r\n    playerPosition = { x: 0, y: 0 };\r\n    score = 0;\r\n    roomsVisited = 0;\r\n    scoreTotal.text(score);\r\n    roomsTraveled.text(roomsVisited);\r\n}\r\n","function validateMaze(data) {\n    let result = { isValid: true, message: '' };\n\n    if (!hasSingleExit(data)) {\n        result.isValid = false;\n        result.message = 'Maze must have exactly one exit.';\n        return result;\n    }\n\n    if (!validateDoorIntegrity(data)) {\n        result.isValid = false;\n        result.message = 'Some rooms have doors that lead to nowhere.';\n        return result;\n    }\n\n    if (!isMazeSolvable(data)) {\n        result.isValid = false;\n        result.message = 'The maze is not solvable from every room.';\n        return result;\n    }\n\n    return result;\n}\n\nfunction hasSingleExit(data) {\n    let exitCount = 0;\n    let exitLocations = [];\n\n    for (let i = 0; i < data.rooms.length; i++) {\n        const row = data.rooms[i];\n        for (let j = 0; j < row.length; j++) {\n            const room = row[j];\n            if (room.encounter === \"exit\") {\n                exitCount++;\n                exitLocations.push(`row ${i + 1}, column ${j + 1}`);\n            }\n        }\n    }\n\n    if (exitCount !== 1) {\n        console.log(`Invalid number of exits: ${exitCount}. Exits found at ${exitLocations.join(', ')}.`);\n    }\n\n    return exitCount === 1;\n}\n\nfunction validateDoorIntegrity(data) {\n    const rows = data.rooms.length;\n    const cols = data.rooms[0].length;\n\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            const room = data.rooms[i][j];\n            const doors = room.doors;\n\n            if (doors.north && (i === 0 || !data.rooms[i - 1][j].doors.south)) {\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the north doesn't match.`);\n                return false;\n            }\n            if (doors.south && (i === rows - 1 || !data.rooms[i + 1][j].doors.north)) {\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the south doesn't match.`);\n                return false;\n            }\n            if (doors.east && (j === cols - 1 || !data.rooms[i][j + 1].doors.west)) {\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the east doesn't match.`);\n                return false;\n            }\n            if (doors.west && (j === 0 || !data.rooms[i][j - 1].doors.east)) {\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the west doesn't match.`);\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction isMazeSolvable(data) {\n    const rows = data.rooms.length;\n    const cols = data.rooms[0].length;\n    let exitLocation = null;\n\n    // Find the exit location\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (data.rooms[i][j].encounter === \"exit\") {\n                exitLocation = { row: i, col: j };\n                break;\n            }\n        }\n        if (exitLocation) break;\n    }\n\n    // Depth-first search function to explore the maze\n    function dfs(row, col, visited) {\n        if (row < 0 || row >= rows || col < 0 || col >= cols || visited[row][col]) {\n            return false;\n        }\n\n        if (row === exitLocation.row && col === exitLocation.col) {\n            return true;\n        }\n\n        visited[row][col] = true;\n\n        const doors = data.rooms[row][col].doors;\n\n        return (doors.north && dfs(row - 1, col, visited)) ||\n            (doors.south && dfs(row + 1, col, visited)) ||\n            (doors.east && dfs(row, col + 1, visited)) ||\n            (doors.west && dfs(row, col - 1, visited));\n    }\n\n    // Check solvability from each room\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            const visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n            if (!dfs(i, j, visited)) {\n                console.log(`Maze is not solvable from row ${i + 1}, column ${j + 1}.`);\n                return false;\n            }\n        }\n    }\n\n    return true;\n}","function announce(message) {\n    $('#announcer').text(message);\n}\n\nfunction encounterAnnounce(message) {\n    $('#encounterAnnouncer').text(message);\n}\n\nfunction closeDoors() {\n    $('.doors').addClass('closed');\n}\n\nfunction openDoors() {\n    $('.doors').removeClass('closed');\n}\n\nfunction getRandomInt(max) {\n    return Math.floor(Math.random() * max);\n}\n\nfunction getDistance(pos1, pos2) {\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\n}\n\nfunction hideMenuItems() {\n    menuTrolls.hide();\n    levelSelectWrapper.hide();\n    menuHeader.hide();\n\n}\n\nfunction updateScore(amount) {\n    score += amount;\n\n    // Ensure the score doesn't go below zero\n    if (score < 0) {\n        score = 0;\n    }\n\n    // Update the score display\n    scoreTotal.text(score);\n}\n\nfunction getExitCoordinates(data) {\n    for (let i = 0; i < data.mazeSize; i++) {\n        for (let j = 0; j < data.mazeSize; j++) {\n            if (data.rooms[i][j].encounter === \"exit\") {\n                return { x: j, y: i };\n            }\n        }\n    }\n    return null; // Should never happen if it passes the validation but just in case.\n}\n\n// Kinda cheating if user knows about it but it's a good way to test the maze.\nfunction renderMazeInConsole() {\n    let visualization = \"\";\n\n    for (let i = 0; i < mazeSize; i++) {\n        for (let j = 0; j < mazeSize; j++) {\n            if (j == 0) {\n                visualization += \"|\";\n            }\n\n            if (playerPosition.y == i && playerPosition.x == j) {\n                visualization += \" X \";\n            } else {\n                visualization += \"   \";\n            }\n\n            visualization += \"|\";\n        }\n        visualization += \"\\n\";\n        visualization += Array(mazeSize * 4 + 1).join(\"_\");\n        visualization += \"\\n\";\n    }\n\n    console.log(visualization);\n}"]}