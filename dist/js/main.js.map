{"version":3,"sources":["movement.js","script.js","tests.js","utilities.js"],"names":["movePlayer","direction","let","newX","playerPosition","x","newY","y","canMoveTo","leaveRoomInDirection","roomsVisited","roomsTraveled","text","setTimeout","enterRoomFromDirection","announce","mazeSize","maze","doors","isEncounterInThatRoom","encounter","animationName","$","addClass","removeClass","moveToCenter","enterRoom","hero","fromClass","directionMap","fromNorthEncounter","fromSouthEncounter","fromEastEncounter","fromWestEncounter","hasClass","mazeData","score","duringGame","duringEncounter","question","flagQuestion","enemyTimer","previousAnnouncement","directions","levelSelectWrapper","levelSelect","menuTrolls","menuHeader","scoreTotal","north","east","south","west","loadMaze","level","val","ajax","url","type","dataType","success","data","validationResult","validateMaze","isValid","initializeMaze","updateMazeVisualization","loadBackgroundImages","background","alert","message","error","backgroundSrc","loadedBackgroundImg","i","append","last","rooms","mazeEnemies","Object","keys","enemies","mazeTreasures","treasures","exit","getExitCoordinates","j","visited","getRandomInt","getDistance","handleUserInput","input","toggleHelpModal","insertFlag","resetGame","encounterAnnounce","includes","handleEncounterInput","hideMenuItems","color","flag","updateScore","checkForFlag","remove","currentRoom","toggleClass","startEnemyTimer","numEnemies","setInterval","clearInterval","stopEnemyTimer","encounters","currentEncounter","Array","isArray","encounterData","action","victory","find","first","shift","remainingEnemies","filter","e","length","value","openDoors","handleEncounter","closeDoors","renderMazeInConsole","displayEncounter","announcement","gameOver","show","not","room","empty","forEach","item","content","image","attr","result","hasSingleExit","validateDoorIntegrity","isMazeSolvable","exitCount","exitLocations","row","push","console","log","join","rows","cols","exitLocation","col","from","fill","dfs","max","Math","floor","random","pos1","pos2","abs","hide","amount","visualization","on","keypress","which","this","toLowerCase"],"mappings":"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","file":"main.js","sourcesContent":["function movePlayer(direction) {\n    let newX = playerPosition.x;\n    let newY = playerPosition.y;\n\n    switch (direction) {\n        case \"north\": newY--; break;\n        case \"south\": newY++; break;\n        case \"east\": newX++; break;\n        case \"west\": newX--; break;\n    }\n\n    if (canMoveTo(newX, newY, direction)) {\n        leaveRoomInDirection(direction);\n        roomsVisited++;\n        roomsTraveled.text(roomsVisited);\n        setTimeout(function () {\n            playerPosition.x = newX;\n            playerPosition.y = newY;\n            enterRoomFromDirection(direction);\n        }, 1000);\n    } else {\n        announce(\"You can't go that way!\");\n    }\n}\n\nfunction canMoveTo(x, y, direction) {\n    return x >= 0 && y >= 0 && x < mazeSize && y < mazeSize && maze[playerPosition.y][playerPosition.x].doors[direction];\n}\n\nfunction enterRoomFromDirection(direction) {\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\n    let isEncounterInThatRoom = currentRoom.encounter !== null;\n    let animationName = '';\n\n    switch (direction) {\n        case \"north\":\n            animationName = isEncounterInThatRoom ? 'fromSouthEncounter' : 'arriveFromSouth';\n            break;\n        case \"south\":\n            animationName = isEncounterInThatRoom ? 'fromNorthEncounter' : 'arriveFromNorth';\n            break;\n        case \"east\":\n            animationName = isEncounterInThatRoom ? 'fromWestEncounter' : 'arriveFromWest';\n            break;\n        case \"west\":\n            animationName = isEncounterInThatRoom ? 'fromEastEncounter' : 'arriveFromEast';\n            break;\n    }\n\n    $('.hero').addClass(animationName);\n    // Wait for the animation to finish\n    setTimeout(function () {\n        // if it's an encounter, dont remove the animation class\n        if (!isEncounterInThatRoom) {\n            $('.hero').removeClass(animationName);\n            moveToCenter();\n        }\n    }, 1000);\n    enterRoom();\n}\n\nfunction leaveRoomInDirection(direction) {\n    let animationName = '';\n    switch (direction) {\n        case \"north\":\n            animationName = 'leaveToNorth';\n            break;\n        case \"south\":\n            animationName = 'leaveToSouth';\n            break;\n        case \"east\":\n            animationName = 'leaveToEast';\n            break;\n        case \"west\":\n            animationName = 'leaveToWest';\n            break;\n    }\n    $('.hero').addClass(animationName);\n    // Wait for the animation to finish\n    setTimeout(function () {\n        $('.hero').removeClass(animationName);\n    }, 1000);\n\n}\n\nfunction moveToCenter() {\n    const hero = $('.hero');\n    const directionMap = {\n        'fromNorthEncounter': 'toCenterFromNorth',\n        'fromSouthEncounter': 'toCenterFromSouth',\n        'fromEastEncounter': 'toCenterFromEast',\n        'fromWestEncounter': 'toCenterFromWest',\n    };\n\n    for (let fromClass in directionMap) {\n        if (hero.hasClass(fromClass)) {\n            hero.addClass(directionMap[fromClass])\n                .removeClass(fromClass);\n            break;\n        }\n    }\n\n    // now after animation finishes after 1 sec remove the toCenter class\n    setTimeout(function () {\n        hero.removeClass('toCenterFromNorth toCenterFromSouth toCenterFromEast toCenterFromWest');\n    }, 1000);\n}","let mazeData = null;\r\n\r\n// Global variables\r\nlet playerPosition = { x: 0, y: 0 };\r\nlet score = 0;\r\nlet roomsVisited = 0;\r\nlet duringGame = false;\r\nlet duringEncounter = false;\r\nlet question = false;\r\nlet flagQuestion = false;\r\nlet enemyTimer; // to hold the interval for decrementing score due to enemies\r\n\r\n// Needed to store the previous announcement when the player is asked a question\r\nlet previousAnnouncement = null;\r\n\r\nconst directions = [\"north\", \"south\", \"east\", \"west\"];\r\n\r\n// html elements\r\nlet levelSelectWrapper = $('.maze__level-select');\r\nlet levelSelect = $('#level');\r\nlet menuTrolls = $('.dancing-troll');\r\nlet menuHeader = $('.menu__heading');\r\nlet scoreTotal = $('#score');\r\nlet roomsTraveled = $('#rooms');\r\n\r\nconst doors = {\r\n    north: '<span class=\"doors doors--north\"></span>',\r\n    east: '<span class=\"doors doors--east\"></span>',\r\n    south: '<span class=\"doors doors--south\"></span>',\r\n    west: '<span class=\"doors doors--west\"></span>'\r\n}\r\n\r\n// toggle help modal on click\r\n$('#closeModal').on('click', toggleHelpModal);\r\n\r\n// User input handling\r\n$(\"#userInput\").keypress(function (e) {\r\n    if (e.which === 13) { // Enter key pressed\r\n        let input = $(this).val().toLowerCase();\r\n        handleUserInput(input);\r\n        // clear the input field\r\n        $(this).val(\"\");\r\n    }\r\n});\r\n\r\nfunction loadMaze() {\r\n    let level = levelSelect.val();\r\n\r\n    $.ajax({\r\n        url: './maze-configs/' + level + '.json',\r\n        type: 'GET',\r\n        dataType: 'json',\r\n        success: function (data) {\r\n            const validationResult = validateMaze(data);\r\n            if (validationResult.isValid) {\r\n                mazeData = data;\r\n                initializeMaze(data);\r\n                updateMazeVisualization();\r\n\r\n                // Load the background images\r\n                loadBackgroundImages(data.background);\r\n            } else {\r\n                alert(`Invalid maze configuration: ${validationResult.message}`);\r\n            }\r\n        },\r\n        error: function () {\r\n            alert('Failed to load maze.');\r\n        }\r\n    });\r\n}\r\n\r\nfunction loadBackgroundImages(backgroundSrc) {\r\n    // Load the background images\r\n    let loadedBackgroundImg = '<img class=\"maze__menu-background\" src=\"' + backgroundSrc + '\" alt=\"Background\">';\r\n\r\n    // create 4 copies of the background image, add class maze__menu-background-- + number to each and append to #maze\r\n    for (let i = 1; i < 5; i++) {\r\n        $('#maze').append(loadedBackgroundImg);\r\n        $('.maze__menu-background').last().addClass('maze__menu-background--' + i);\r\n    }\r\n}\r\n\r\nfunction initializeMaze(data) {\r\n    mazeSize = data.mazeSize;\r\n    maze = data.rooms;\r\n    mazeEnemies = Object.keys(data.enemies);  // get enemy keys\r\n    mazeTreasures = Object.keys(data.treasures);  // get treasure keys\r\n    exit = getExitCoordinates(data);\r\n\r\n    for (let i = 0; i < mazeSize; i++) {\r\n        for (let j = 0; j < mazeSize; j++) {\r\n            maze[i][j].visited = false;\r\n        }\r\n    }\r\n\r\n    do {\r\n        playerPosition.x = getRandomInt(mazeSize);\r\n        playerPosition.y = getRandomInt(mazeSize);\r\n    } while (getDistance(playerPosition, exit) < 3);\r\n\r\n    // Clear the encounter in the initial room\r\n    maze[playerPosition.y][playerPosition.x].encounter = null;\r\n    maze[playerPosition.y][playerPosition.x].visited = true;\r\n}\r\n\r\nfunction handleUserInput(input) {\r\n\r\n    if (input === \"start\" && !duringGame) {\r\n        duringGame = true;\r\n        resetGame();\r\n        hideMenuItems();\r\n        loadMaze();\r\n        announce(\"You are in a maze. Try to find the exit. Type 'help' for more instructions.\");\r\n    } else if (input === \"help\") {\r\n        toggleHelpModal();\r\n    } else if (input === \"start\" && duringGame) {\r\n        previousAnnouncement = $('#announcer').text();\r\n        announce(\"Do you want to return to the main menu? Type 'yes' or 'no'.\");\r\n        question = true;\r\n    } else if (input === 'flag' && !duringEncounter) {\r\n        previousAnnouncement = $('#announcer').text();\r\n        announce(\"Insert flag for 100 points. Pick color, type 'red', 'green', 'yellow' or 'cancel' to cancel.\");\r\n        flagQuestion = true;\r\n    } else if (flagQuestion) {\r\n        if (input === 'red' || input === 'green' || input === 'yellow') {\r\n            // set flag\r\n            insertFlag(input);\r\n        } else if (input === 'cancel') {\r\n            // cancel flag setting\r\n            flagQuestion = false;\r\n            announce(previousAnnouncement);\r\n        } else {\r\n            announce(\"Unknown flag color. Type 'red', 'green', 'yellow' or 'cancel' to cancel.\");\r\n        }\r\n    } else if (question) {\r\n        if (input === \"yes\") {\r\n            // Reset everything\r\n            duringGame = false;\r\n            duringEncounter = false;\r\n            question = false;\r\n            resetGame();\r\n            announce(\"Game has been reset. Type 'start' to begin again.\");\r\n        } else if (input === \"no\") {\r\n            // Continue game\r\n            question = false;\r\n            announce(previousAnnouncement);\r\n        } else {\r\n            encounterAnnounce(\"Please answer with 'yes' or 'no'.\");\r\n        }\r\n    } else if (directions.includes(input)) {\r\n        // Check if the player is during an encounter. If so, notify them and prevent movement.\r\n        if (duringEncounter) {\r\n            encounterAnnounce(\"You can't leave until you've dealt with the encounter!\");\r\n        } else {\r\n            movePlayer(input);\r\n        }\r\n    } else if (duringEncounter) {\r\n        // Handle the encounter input\r\n        handleEncounterInput(input);\r\n    } else {\r\n        announce(\"Unknown command. Type 'help' for more instructions.\");\r\n    }\r\n}\r\n\r\nfunction insertFlag(color) {\r\n    // set current room encounter to red flag\r\n    maze[playerPosition.y][playerPosition.x].flag = color + '-flag';\r\n    flagQuestion = false;\r\n\r\n    // deduct 100 from score and show new score\r\n    updateScore(-100);\r\n\r\n    encounterAnnounce(color + \" flag set in this room!\");\r\n    announce(previousAnnouncement);\r\n    // add flag img to the room\r\n    $('#maze').append('<img class=\"flag\" src=\"./dist/assets/flags/' + color + '-flag.jpg\" alt=\"Flag\">');\r\n}\r\n\r\nfunction checkForFlag() {\r\n    // Remove any existing flag images\r\n    $('.flag').remove();\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n\r\n    if (currentRoom.flag) {\r\n        // add flag img to the room\r\n        $('#maze').append('<img class=\"flag\" src=\"./dist/assets/flags/' + currentRoom.flag + '.jpg\" alt=\"Flag\">');\r\n    }\r\n}\r\n\r\nfunction toggleHelpModal() {\r\n    $('.help-modal').toggleClass('hidden');\r\n}\r\n\r\nfunction startEnemyTimer(numEnemies) {\r\n    enemyTimer = setInterval(function () {\r\n        updateScore(-100 * numEnemies);\r\n        // Stop the timer if score reaches zero\r\n        if (score <= 0) {\r\n            clearInterval(enemyTimer);\r\n            updateScore(0);\r\n        }\r\n    }, 2000);\r\n}\r\n\r\nfunction stopEnemyTimer() {\r\n    clearInterval(enemyTimer);\r\n}\r\n\r\n\r\nfunction handleEncounterInput(input) {\r\n    if (!duringEncounter) return;\r\n\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    let encounters = currentRoom.encounter;\r\n\r\n    if (!encounters) return;\r\n\r\n    encounters = Array.isArray(encounters) ? encounters : [encounters];\r\n    const currentEncounter = encounters[0];\r\n\r\n    let encounterData;\r\n    if (mazeData.enemies[currentEncounter]) {\r\n        encounterData = mazeData.enemies[currentEncounter];\r\n    } else if (mazeData.treasures[currentEncounter]) {\r\n        encounterData = mazeData.treasures[currentEncounter];\r\n    } else if (currentEncounter === \"exit\") {\r\n        encounterData = { action: 'exit', victory: `You've found the exit! Congratulations.` };\r\n    }\r\n\r\n    if (input === encounterData.action) {\r\n        encounterAnnounce(encounterData.victory);\r\n\r\n        // Stop the existing enemy timer\r\n        clearInterval(enemyTimer);\r\n\r\n        // Add 'defeated' class to the next non-defeated image\r\n        $(\"#encounter\").find(\"img:not(.defeated)\").first().addClass('defeated');\r\n\r\n        encounters.shift(); // Remove the handled encounter\r\n\r\n        const remainingEnemies = encounters.filter(e => mazeEnemies.includes(e)).length;\r\n\r\n        if (remainingEnemies > 0) {\r\n            startEnemyTimer(remainingEnemies);\r\n        }\r\n\r\n        if (mazeData.treasures[currentEncounter]) {\r\n            updateScore(mazeData.treasures[currentEncounter].value);\r\n        }\r\n\r\n        if (encounters.length === 0) {\r\n            announce(\"Room cleared! Move on to the next room.\");\r\n            currentRoom.encounter = null;\r\n            duringEncounter = false;\r\n            stopEnemyTimer();  // Stop decrementing score due to enemies\r\n            moveToCenter();\r\n            openDoors();\r\n        } else {\r\n            // Update the timer for remaining enemies\r\n            stopEnemyTimer();\r\n            startEnemyTimer(remainingEnemies);\r\n            // Otherwise, proceed to the next encounter in the list\r\n            handleEncounter();\r\n        }\r\n    } else {\r\n        encounterAnnounce(\"Wrong action! Try again.\");\r\n    }\r\n}\r\n\r\nfunction updateMazeVisualization() {\r\n    // Clear any existing door elements from the previous room\r\n    $('.doors').remove();\r\n\r\n    // Fetch the current room based on player's position\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n\r\n    // Check for available doors and inject them into the maze\r\n    for (const direction in currentRoom.doors) {\r\n        if (currentRoom.doors[direction]) {\r\n            $(\"#maze\").append(doors[direction]);\r\n        }\r\n    }\r\n}\r\n\r\nfunction enterRoom() {\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n\r\n    // Reset encounterAnnouncer\r\n    encounterAnnounce(\"\");\r\n\r\n    if (!currentRoom.visited && currentRoom.encounter !== null) {\r\n\r\n        // Remove flag img from the room if arrived from room where you set one\r\n        $('.flag').remove();\r\n\r\n        // Mark the room as visited\r\n        currentRoom.visited = true;\r\n\r\n        // Update the maze visualization\r\n        updateMazeVisualization();\r\n\r\n        // Initiate encounter state\r\n        duringEncounter = true;\r\n\r\n        // After 1 sec close doors\r\n        setTimeout(function () {\r\n            closeDoors();\r\n        }, 1000);\r\n\r\n        handleEncounter();\r\n\r\n        // after 2 sec add class 'fight' to elements .enemy--wrapper\r\n        setTimeout(function () {\r\n            $('.enemy--wrapper').addClass('fight');\r\n        }, 2000);\r\n\r\n        // Start decrementing score for each remaining undefeated enemy\r\n        if (Array.isArray(currentRoom.encounter)) {\r\n            const numEnemies = currentRoom.encounter.filter(e => mazeEnemies.includes(e)).length;\r\n            if (numEnemies > 0) {\r\n                startEnemyTimer(numEnemies);\r\n            }\r\n        } else if (mazeEnemies.includes(currentRoom.encounter)) {\r\n            startEnemyTimer(1);\r\n        }\r\n\r\n    } else {\r\n        announce(\"Nothing in this room\");\r\n        updateMazeVisualization();\r\n        checkForFlag();\r\n    }\r\n\r\n    renderMazeInConsole();\r\n    displayEncounter(currentRoom);\r\n}\r\n\r\nfunction handleEncounter() {\r\n    const currentRoom = maze[playerPosition.y][playerPosition.x];\r\n    let encounters = currentRoom.encounter;\r\n\r\n    if (!encounters) return;\r\n\r\n    encounters = Array.isArray(encounters) ? encounters : [encounters];\r\n    const currentEncounter = encounters[0];\r\n\r\n    if (mazeEnemies.includes(currentEncounter)) {\r\n        const enemyData = mazeData.enemies[currentEncounter];\r\n        announce(enemyData.announcement);\r\n    } else if (mazeTreasures.includes(currentEncounter)) {\r\n        const treasureData = mazeData.treasures[currentEncounter];\r\n        announce(treasureData.announcement);\r\n    } else if (currentEncounter === 'exit') {\r\n        announce(\"You've found the exit! Congratulations.\");\r\n        gameOver();\r\n    }\r\n}\r\n\r\nfunction gameOver() {\r\n    duringGame = false;\r\n    duringEncounter = false;\r\n\r\n    menuTrolls.show();\r\n    levelSelectWrapper.show();\r\n    menuHeader.show();\r\n\r\n    // add .game-over class to the hero element, .maze__score and .maze__rooms\r\n    $('.hero').addClass('game-over');\r\n    $('.maze__score').addClass('game-over');\r\n    $('.maze__rooms').addClass('game-over');\r\n\r\n    // delete the background images but not the .dancing-troll\r\n    $('.maze__menu-background').not('.dancing-troll').remove();\r\n\r\n    encounterAnnounce(\"Type start to play again.\");\r\n\r\n}\r\n\r\nfunction displayEncounter(room) {\r\n    $('#encounter').empty();\r\n    if (room.encounter) {\r\n        const encounters = Array.isArray(room.encounter) ? room.encounter : [room.encounter];\r\n\r\n        encounters.forEach(item => {\r\n            let content = '';\r\n            if (mazeEnemies.includes(item)) {\r\n                content = mazeData.enemies[item].image;\r\n                content = `<div class=\"enemy--wrapper\">${content}</div>`;\r\n            } else if (mazeTreasures.includes(item)) {\r\n                content = mazeData.treasures[item].image;\r\n            } else if (item === \"exit\") {\r\n                content = '<img src=\"./dist/assets/exit.png\" alt=\"Exit\">';\r\n            }\r\n\r\n            $(\"#encounter\").append(content);\r\n        });\r\n    }\r\n}\r\n\r\nfunction resetGame() {\r\n    // Revert all hidden menu items\r\n    menuTrolls.show();\r\n    levelSelectWrapper.show();\r\n    menuHeader.show();\r\n\r\n    // remove .game-over class from the hero element, .maze__score and .maze__rooms\r\n    $('.hero').removeClass('game-over');\r\n    $('.maze__score').removeClass('game-over');\r\n    $('.maze__rooms').removeClass('game-over');\r\n\r\n    // delete the background images but not the .dancing-troll\r\n    $('.maze__menu-background').not('.dancing-troll').remove();\r\n\r\n    // Remove other classes from the hero element apart from .hero\r\n    $('.hero').attr('class', 'hero');\r\n\r\n    // Remove all images from the #encounter container\r\n    $('#encounter').empty();\r\n\r\n    // Unload Maze\r\n    maze = null;\r\n    mazeData = null;\r\n    playerPosition = { x: 0, y: 0 };\r\n    score = 0;\r\n    roomsVisited = 0;\r\n    scoreTotal.text(score);\r\n    roomsTraveled.text(roomsVisited);\r\n}\r\n","function validateMaze(data) {\n    let result = { isValid: true, message: '' };\n\n    if (!hasSingleExit(data)) {\n        result.isValid = false;\n        result.message = 'Maze must have exactly one exit.';\n        return result;\n    }\n\n    if (!validateDoorIntegrity(data)) {\n        result.isValid = false;\n        result.message = 'Some rooms have doors that lead to nowhere.';\n        return result;\n    }\n\n    if (!isMazeSolvable(data)) {\n        result.isValid = false;\n        result.message = 'The maze is not solvable from every room.';\n        return result;\n    }\n\n    return result;\n}\n\nfunction hasSingleExit(data) {\n    let exitCount = 0;\n    let exitLocations = [];\n\n    for (let i = 0; i < data.rooms.length; i++) {\n        const row = data.rooms[i];\n        for (let j = 0; j < row.length; j++) {\n            const room = row[j];\n            if (room.encounter === \"exit\") {\n                exitCount++;\n                exitLocations.push(`row ${i + 1}, column ${j + 1}`);\n            }\n        }\n    }\n\n    if (exitCount !== 1) {\n        console.log(`Invalid number of exits: ${exitCount}. Exits found at ${exitLocations.join(', ')}.`);\n    }\n\n    return exitCount === 1;\n}\n\nfunction validateDoorIntegrity(data) {\n    const rows = data.rooms.length;\n    const cols = data.rooms[0].length;\n\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            const room = data.rooms[i][j];\n            const doors = room.doors;\n\n            if (doors.north && (i === 0 || !data.rooms[i - 1][j].doors.south)) {\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the north doesn't match.`);\n                return false;\n            }\n            if (doors.south && (i === rows - 1 || !data.rooms[i + 1][j].doors.north)) {\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the south doesn't match.`);\n                return false;\n            }\n            if (doors.east && (j === cols - 1 || !data.rooms[i][j + 1].doors.west)) {\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the east doesn't match.`);\n                return false;\n            }\n            if (doors.west && (j === 0 || !data.rooms[i][j - 1].doors.east)) {\n                console.log(`Integrity failed at row ${i + 1}, column ${j + 1}: Door to the west doesn't match.`);\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction isMazeSolvable(data) {\n    const rows = data.rooms.length;\n    const cols = data.rooms[0].length;\n    let exitLocation = null;\n\n    // Find the exit location\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (data.rooms[i][j].encounter === \"exit\") {\n                exitLocation = { row: i, col: j };\n                break;\n            }\n        }\n        if (exitLocation) break;\n    }\n\n    // Depth-first search function to explore the maze\n    function dfs(row, col, visited) {\n        if (row < 0 || row >= rows || col < 0 || col >= cols || visited[row][col]) {\n            return false;\n        }\n\n        if (row === exitLocation.row && col === exitLocation.col) {\n            return true;\n        }\n\n        visited[row][col] = true;\n\n        const doors = data.rooms[row][col].doors;\n\n        return (doors.north && dfs(row - 1, col, visited)) ||\n            (doors.south && dfs(row + 1, col, visited)) ||\n            (doors.east && dfs(row, col + 1, visited)) ||\n            (doors.west && dfs(row, col - 1, visited));\n    }\n\n    // Check solvability from each room\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            const visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n            if (!dfs(i, j, visited)) {\n                console.log(`Maze is not solvable from row ${i + 1}, column ${j + 1}.`);\n                return false;\n            }\n        }\n    }\n\n    return true;\n}","function announce(message) {\n    $('#announcer').text(message);\n}\n\nfunction encounterAnnounce(message) {\n    $('#encounterAnnouncer').text(message);\n}\n\nfunction closeDoors() {\n    $('.doors').addClass('closed');\n}\n\nfunction openDoors() {\n    $('.doors').removeClass('closed');\n}\n\nfunction getRandomInt(max) {\n    return Math.floor(Math.random() * max);\n}\n\nfunction getDistance(pos1, pos2) {\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\n}\n\nfunction hideMenuItems() {\n    menuTrolls.hide();\n    levelSelectWrapper.hide();\n    menuHeader.hide();\n\n}\n\nfunction updateScore(amount) {\n    score += amount;\n\n    // Ensure the score doesn't go below zero\n    if (score < 0) {\n        score = 0;\n    }\n\n    // Update the score display\n    scoreTotal.text(score);\n}\n\nfunction getExitCoordinates(data) {\n    for (let i = 0; i < data.mazeSize; i++) {\n        for (let j = 0; j < data.mazeSize; j++) {\n            if (data.rooms[i][j].encounter === \"exit\") {\n                return { x: j, y: i };\n            }\n        }\n    }\n    return null; // Should never happen if it passes the validation but just in case.\n}\n\n// Kinda cheating if user knows about it but it's a good way to test the maze.\nfunction renderMazeInConsole() {\n    let visualization = \"\";\n\n    for (let i = 0; i < mazeSize; i++) {\n        for (let j = 0; j < mazeSize; j++) {\n            if (j == 0) {\n                visualization += \"|\";\n            }\n\n            if (playerPosition.y == i && playerPosition.x == j) {\n                visualization += \" X \";\n            } else {\n                visualization += \"   \";\n            }\n\n            visualization += \"|\";\n        }\n        visualization += \"\\n\";\n        visualization += Array(mazeSize * 4 + 1).join(\"_\");\n        visualization += \"\\n\";\n    }\n\n    console.log(visualization);\n}"]}